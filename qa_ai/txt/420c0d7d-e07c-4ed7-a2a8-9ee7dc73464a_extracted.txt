TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ  
KHOA CÔNG K Ỹ THU ẬT CÔNG NGH Ệ 
 
 
TÀI LI ỆU GI ẢNG D ẠY 
HỆ ĐIỀU HÀNH  
(OPERATING  SYSTEM)  
 
 
 
 
 
Lƣu hành n ội bộ, 2019

MỤC LỤC 
CHƢƠNG 1. KHÁI NI ỆM CƠ B ẢN H Ệ THỐNG MÁY TÍNH VÀ H Ệ ĐIỀU 
HÀNH  ................................ ................................ ................................ ................................ . 1 
1.1 KHÁI NI ỆM V Ề HỆ ĐIỀU HÀNH  ................................ ................................ .... 1 
1.1.1.  Khái ni ệm ................................ ................................ ................................ ....... 1 
1.1.2.  Mục tiêu c ủa hệ điều hành  ................................ ................................ ............  2 
1.1.3.  Chức năng c ủa hệ điều hành  ................................ ................................ ........  2 
2.1 PHÂN LO ẠI HỆ ĐIỀU HÀNH  ................................ ................................ ..........  2 
2.1.1.  Hệ thống xử lý theo lô đơn gi ản (Simple Batch System)  ...........................  2 
2.1.2.  Hệ thống xử lý theo lô đa chƣơng (Multiprogrammed Batch System)  .... 3 
2.1.3.  Hệ thống chia s ẻ thời gian (Time Sharing System)  ................................ .... 4 
2.1.4.  Hệ thống song song (Parallel System)  ................................ .........................  4 
2.1.5.  Hệ thống phân tán (Distributed System)  ................................ ....................  5 
2.1.6.  Hệ thống xử lý th ời gian th ực (Real Time System)  ................................ .... 6 
2.1.7.  Hệ thống nhúng (Embedded Systems)  ................................ ........................  6 
TÓM T ẮT CHƢƠNG  ................................ ................................ ................................ .... 7 
BÀI T ẬP ................................ ................................ ................................ ..........................  7 
CHƢƠNG 2. GIAO DI ỆN LẬP TRÌNH VÀ XÂY D ỰNG H Ệ ĐIỀU HÀNH .............  8 
2.1. CÁC THÀNH PH ẦN CỦA HỆ THỐNG ................................ ..........................  8 
2.1.1.  Quản lý ti ến trình  ................................ ................................ ..........................  8 
2.1.2.  Quản lý b ộ nhớ chính  ................................ ................................ ....................  8 
2.1.3.  Quản lý b ộ nhớ phụ ................................ ................................ .......................  8 
2.1.4.  Quản lý nh ập xuất ................................ ................................ .........................  9 
2.1.5.  Quản lý t ập tin  ................................ ................................ ...............................  9 
2.1.6.  Hệ thống bảo vệ ................................ ................................ .............................  9 
2.1.7.  Quản lý m ạng ................................ ................................ ...............................  10 
2.1.8.  Hệ thông d ịch lệnh ................................ ................................ ......................  10 
2.2. CÁC D ỊCH V Ụ CỦA HỆ ĐIỀU HÀNH (SYSTEM SERVICES)  .................  10 
2.3. LỜI GỌI HỆ THỐNG (SYSTEM CALL)  ................................ ......................  11 
2.4. CÁC CHƢƠNG TRÌNH H Ệ THỐNG ................................ .............................  12
TÓM T ẮT CHƢƠNG  ................................ ................................ ................................ .. 13 
BÀI T ẬP ................................ ................................ ................................ ........................  13 
CHƢƠNG 3. C ẤU TRÚC H Ệ ĐIỀU HÀNH  ................................ ................................  14 
3.1. CẤU TRÚC H Ệ THỐNG ................................ ................................ ..................  14 
3.1.1.  Cấu trúc đơn gi ản (Monolithique)  ................................ .............................  14 
3.1.2.  Cấu trúc phân l ớp (Layered)  ................................ ................................ ..... 15 
3.1.3.  Máy ảo (Virtual Machine)  ................................ ................................ ..........  16 
3.1.4.  Mô hình Client – Server (Microkernel)  ................................ ....................  17 
3.2. NGUYÊN LÝ THI ẾT KẾ HỆ ĐIỀU HÀNH  ................................ ..................  18 
TÓM T ẮT CHƢƠNG  ................................ ................................ ................................ .. 19 
BÀI T ẬP ................................ ................................ ................................ ........................  19 
CHƢƠNG 4. FILE VÀ THAO TÁC FILE  ................................ ................................ ... 20 
4.1. CÁC KHÁI NI ỆM CƠ B ẢN ................................ ................................ .............  20 
4.1.1.  Bộ nhớ ngoài  ................................ ................................ ................................  20 
4.1.2.  Tập tin và thƣ m ục ................................ ................................ ......................  20 
4.2. MÔ HÌNH QU ẢN LÝ VÀ T Ổ CHỨC CÁC T ẬP TIN  ................................ .. 20 
4.2.1.  Mô hình  ................................ ................................ ................................ ........  20 
4.2.2.  Các ch ức năng  ................................ ................................ ..............................  23 
4.3. CÀI Đ ẶT HỆ THỐNG QU ẢN LÝ T ẬP TIN  ................................ ..................  25 
4.3.1.  Giới thiệu ................................ ................................ ................................ ...... 25 
4.3.2.  Cài đ ặt bảng phân ph ối vùng nh ớ ................................ .............................  26 
4.3.3.  Quản lý các kh ối trống ................................ ................................ ................  29 
4.3.4.  Quản lý kh ối hỏng ................................ ................................ .......................  30 
TÓM T ẮT CHƢƠNG  ................................ ................................ ................................ .. 31 
BÀI T ẬP ................................ ................................ ................................ ........................  31 
CHƢƠNG 5. TI ẾN TRÌNH VÀ DÒNG  ................................ ................................ ........  33 
5.1. TIẾN TRÌNH (PROCESS)  ................................ ................................ ................  33 
5.1.1.  Khái ni ệm ................................ ................................ ................................ ..... 33 
5.1.2.  Mô hình ti ến trình  ................................ ................................ .......................  33 
5.1.3.  Các tr ạng thái c ủa tiến trình  ................................ ................................ ...... 33
5.1.4.  Chế độ xử lý của tiến trình  ................................ ................................ .........  34 
5.1.5.  Cấu trúc d ữ liệu kh ối quản lý ti ến trình  ................................ ...................  35 
5.1.6. Thao tác trên ti ến trình  ................................ ................................ ..................  36 
5.1.7. Chuy ển đổi ngữ cảnh (Context switch)  ................................ .........................  36 
5.1.8.  Cấp phát tài nguyên cho ti ến trình  ................................ ............................  37 
5.2. TI ỂU TRÌNH (THREAD)  ................................ ................................ ....................  37 
5.2.1.  Mô hình ti ểu trình (Thread Model)  ................................ ...........................  38 
5.2.2.  Ví dụ ................................ ................................ ................................ .............  39 
5.3. ĐIỀU PH ỐI TIẾN TRÌNH (SCHEDULE)  ................................ ......................  40 
5.3.1.  Giới thiệu ................................ ................................ ................................ ...... 40 
5.3.2.  Các chi ến lƣợc điều ph ối ................................ ................................ .............  42 
5.4. ĐỒNG B Ộ HÓA TI ẾN TRÌNH  ................................ ................................ ........  48 
5.4.1.  Giới thiệu ................................ ................................ ................................ ...... 48 
5.4.2.  Các gi ải pháp  ................................ ................................ ...............................  50 
5.5. TẮC NGH ẼN (DEADLOCK)  ................................ ................................ ...........  56 
5.5.1.  Định nghĩa  ................................ ................................ ................................ .... 56 
5.5.2.  Điều kiện xu ất hiện tắc ngh ẽn ................................ ................................ .... 57 
5.5.3.  Đồ thị cấp phát tài nguyên  ................................ ................................ ..........  57 
5.5.4.  Các phƣơng pháp x ử lý tắc ngh ẽn ................................ .............................  58 
5.5.5.  Tránh t ắc ngh ẽn ................................ ................................ ..........................  58 
5.6. QUẢN LÝ B Ộ NHỚ ................................ ................................ ..........................  61 
5.6.1.  Giới thiệu ................................ ................................ ................................ ...... 61 
5.6.2.  Phân trang (paging)  ................................ ................................ ....................  63 
5.6.3.  Phân đoạn................................ ................................ ................................ ..... 67 
5.6.4.  Phân trang k ết hợp phân đo ạn ................................ ................................ .. 69 
5.6.5.  Bộ nhớ ảo (virtual memory)  ................................ ................................ ....... 70 
5.6.6.  Cấp phát khung và thay th ế trang  ................................ .............................  77 
TÓM T ẮT CHƢƠNG  ................................ ................................ ................................ .. 80 
BÀI T ẬP ................................ ................................ ................................ ........................  81

HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  1  CHƢƠNG 1. KHÁI NI ỆM CƠ B ẢN HỆ THỐNG MÁY TÍNH 
VÀ H Ệ ĐIỀU HÀNH  
1.1 KHÁI NI ỆM V Ề HỆ ĐIỀU HÀNH  
Một hệ thống máy tính bao g ồm:  
 Phần cứng (hardware): CPU, b ộ nhớ, các thi ết bị nhập xuất, đây là nh ững 
tài nguyên c ủa máy tính.  
 Phần mềm (software): nh ững chƣơng trình s ử dụng tài nguyên c ủa máy 
tính đ ể giải quy ết các yêu c ầu của ngƣ ời sử dụng (chƣơng trình d ịch, h ệ 
thống cơ s ở dữ liệu, xử lý văn b ản, trò chơi, …).  
 
Hình 1.1 . Sơ đ ồ tổ chức phần cứng đơn gi ản của một hệ thống máy tính  
Đối với các chƣơng trình này có hai cách đ ể truy xu ất tới phần cứng:  
 Truy xu ất trực tiếp: đòi h ỏi ngƣ ời viết chƣơng trình ph ải có nh ững ki ến 
thức về phần cứng. Chƣơng trình vi ết theo cách này s ẽ phụ thuộc vào t ừng 
phần cứng cụ thể và rất khó vi ết, không linh đ ộng.  
 Truy xu ất gián ti ếp thông qua nh ững chƣơng trình h ệ thống. Ngƣ ời lập 
trình s ử dụng ph ần cứng thông qua nh ững tên g ọi, dịch vụ do các chƣơng 
trình h ệ thống cung c ấp, vi ệc truy xu ất cụ thể phần cứng do các chƣơng 
trình này đ ảm nhi ệm. Cách này ti ết kiệm th ời gian, công s ức, giúp cho 
ngƣời lập trình t ập trung hơn vào vi ệc thiết kế chƣơng trình.  
Ngoài ra ngƣ ời dùng c ần có m ột chƣơng trình qu ản lý tài nguyên máy tính, cung 
cấp một giao di ện thân thi ện để sử dụng các chƣơng trình. M ột lớp phần mềm 
đƣợc xây d ựng để đáp ứng nh ững yêu c ầu trên đƣ ợc gọi là h ệ điều hành.  
 Khái ni ệm 1.1.1.
Hệ điều hành là m ột chƣơng trình đóng vai trò trung gian trong vi ệc giao ti ếp 
giữa ngƣ ời sử dụng và ph ần cứng của máy t ính.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  2   Mục tiêu c ủa hệ điều hành  1.1.2.
 Cung c ấp một môi trƣ ờng cho phép ngƣ ời sử dụng phát tri ển và th ực hiện 
các ứng dụng m ột cách d ễ dàng và hi ệu quả.  
 Sử dụng và qu ản lý t ốt phần cứng. Th ể hiện cho ngƣ ời sử dụng m ột máy 
ảo với những đặc trƣng khác và d ễ sử dụng hơn so v ới phần vật lý mà nó 
che d ấu. 
 Chức năng c ủa hệ điều hành  1.1.3.
Theo nguyên t ắc một hệ điều hành ph ải thỏa mãn hai ch ức năng chính y ếu 
sau đây:  
 Quản lý, chia s ẻ tài nguyên: h ệ điều hành c ần có các cơ ch ế và chi ến lƣợc 
thích h ợp để quản lý vi ệc phân ph ối tài nguyên nh ằm nâng cao hi ệu quả sử 
dụng, đ ồng th ời cần đảm bảo việc truy xu ất đến các tài nguyên này là h ợp 
lệ, không x ảy ra sai trái m ất đồng nh ất dữ liệu.  
 Giả lập một máy tính m ở rộng: che d ấu các chi ti ết phần cứng của máy 
tính và gi ới thiệu ngƣ ời dùng m ột máy tính m ở rộng có đ ầy đủ các ch ức 
năng c ủa máy tính th ực nhƣng đơn gi ản và d ễ sử dụng hơn.  
 
 
 
 
 
 
 
 
 
 
Hình 1.2. Mô hình tr ừu tƣợng của một hệ thống máy tính  
2.1 PHÂN LO ẠI HỆ ĐIỀU HÀNH  
2.1.1.  Hệ thống xử lý theo lô đơn gi ản (Simple Batch System)   
Mỗi thời điểm ch ỉ có m ột công vi ệc trong b ộ nhớ, khi th ực hiện xong m ột 
công vi ệc, hệ thống sẽ tự động nạp công vi ệc khác vào và th ực thi.  
a) Bộ giám sát thư ờng tr ực (Resident monitor)  
Thực hiện tuần tự các công vi ệc theo nh ững ch ỉ thị định trƣ ớc. Khi m ột công 
việc chấm dứt, hệ thống sẽ thực hiện công vi ệc kế tiếp mà không c ần có s ự 
can thi ệp của ngƣ ời lập trình, do đó th ời gian th ực hiện sẽ mau hơn. M ột 
chƣơng trình g ọi là b ộ giám sát thƣ ờng tr ực đƣợc thiết kế để giám sát vi ệc 
  
Trình d ịch 
  
  
Hợp ngữ 
  
  
  
Soạn thảo …..  
  
Cơ s ở dữ liệu 
  
Phần mềm hệ thống và ph ần mềm ứng dụng 
  
Hệ điều hành  
  
Phần cứng 
  
User 1  
  
 User  
2 
  
 User 3  
  
 User n
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  3  thực hiện dãy các công vi ệc một các h tự động, chƣơng trình này luôn thƣ ờng 
trú trong b ộ nhớ chính.  
b) CPU và thao tác nh ập xuất  
CPU thƣ ờng hay nhàn r ỗi do t ốc độ làm vi ệc của các thi ết bị nhập xu ất 
(thƣờng là thi ết bị cơ) ch ậm hơn nhi ều lần so v ới các thi ết bị điện tử. Cho dù 
là một CPU c hậm nh ất, nó cũng nhanh hơn r ất nhiều lần so v ới thiết bị nhập 
xuất. Do đó ph ải có các phƣơng pháp đ ể đồng b ộ hóa vi ệc hoạt động của 
CPU và thao tác nh ập xuất.  
 Xử lý offline: CPU s ẽ không truy xu ất trực tiếp thiết bị nhập xuất mà dùng 
bộ lƣu tr ữ trung gia n. CPU ch ỉ thao tác v ới bộ phận này. Vi ệc đọc hay 
xuất đều thực hiện trên b ộ lƣu tr ữ trung gian.  
 Spooling: spool (Simultaneous Peripheral Operations on -line) cơ ch ế đồng 
bộ hóa thao tác trên thi ết bị ngoại vi online, cho phép CPU l ựa chọn công 
việc kế tiếp thực hiện trên thi ết bị trong khi công vi ệc trƣ ớc đang đƣ ợc 
thực hiện (sử dụng hàng đ ợi – queue). Thƣ ờng đƣ ợc sử dụng cho máy in.  
2.1.2.  Hệ thống xử lý theo lô đa chƣơng (Multiprogrammed Batch System)  
Đa chƣơng (multiprogram) là kh ả năng gia tăng khai thác CPU  bằng cách t ổ 
chức các công vi ệc sao cho CPU ph ải luôn ở trong tình tr ạng làm vi ệc.  
Ý tƣởng nhƣ sau: h ệ điều hành lƣu tr ữ một phần của các công vi ệc trong b ộ 
nhớ, CPU s ẽ lần lƣợt thực hiện các công vi ệc này. Khi đang th ực hiện, nếu 
có yêu c ầu truy xu ất thiết bị thì CPU không ngh ỉ mà th ực hiện tiếp công vi ệc 
thứ hai, …  
Ví dụ: Trong b ộ nhớ có ba chƣơng trình th ực hiện ba công vi ệc. Nếu công 
việc 1 yêu c ầu nhập/xuất thì công vi ệc 1 tạm ng ừng, công vi ệc 2 (ho ặc 3) s ẽ 
đƣợc thực hiện, nếu công vi ệc 2 có nh ập/xuất thì s ẽ tạm dừng để thực hiện 
công vi ệc 3, … công vi ệc bị tạm dừng sẽ đƣợc chọn để tiếp tục thực hiện khi 
nào thao tác nh ập/xuất đã hoàn t ất.  
Các ch ức năng c ủa hệ điều hành trong h ệ thống xử lý theo lô đa chƣơng r ất 
phức tạp, bao g ồm:  
 Lập lịch CPU (CPU  Scheduling): ch ọn một trong nh ững công vi ệc trong 
bộ nhớ cho th ực thi (s ử dụng CPU). Khi ch ọn cần tránh trƣ ờng hợp một 
công vi ệc chờ trong b ộ nhớ quá lâu.  
 Quản lý b ộ nhớ (Memory Management): c ần ph ải quản lý ph ần bộ nhớ 
nào đã c ấp phát và c ấp cho công vi ệc nào (b ộ nhớ cấp phát cho m ỗi công 
việc phải riêng bi ệt), ph ần bộ nhớ nào chƣa c ấp, khi m ột công vi ệc thực thi 
xong c ần thu h ồi phần nhớ đã cấp cho công vi ệc đó. N ếu một công vi ệc 
truy xu ất đến phần bộ nhớ đã cấp cho công vi ệc khác thì ph ải ngăn c ấm. 
Nếu bộ nhớ bị phân m ảnh quá nhi ều thì c ần dồn bộ nhớ, …  
 Cấp phát thi ết bị (Allocation of Devices): tình tr ạng thi ết bị rảnh hay 
không r ảnh, thi ết bị đã cấp cho công vi ệc nào, công vi ệc nào c ần đƣa vào
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  4  hàng đ ợi để chờ. Thi ết bị nào có th ể dùng chung và t ối đa bao nhiêu công 
việc sử dụng chung thi ết bị cùng lúc, thi ết bị nào không th ể dùng chung, 
… và ph ải tránh b ị tắc ngh ẽn (các công vi ệc chờ vô hạn để đƣợc cấp tài 
nguyên).  
 Cung c ấp các hàm x ử lý nh ập/xuất (I/O Routines): các hàm nh ập/xuất sẽ 
che d ấu sự phức tạp và đa d ạng của các thi ết bị nhập/xuất, quản lý vi ệc sử 
dụng chung thi ết bị nhập/xuất.  
2.1.3.  Hệ thống chia s ẻ thời gian (Time Sharing System)  
Còn đƣ ợc gọi là h ệ thống đa nhi ệm (multitasking), là m ột mở rộng của hệ 
thống xử lý đa chƣơng. Trong h ệ thống đa nhi ệm, vi ệc chuy ển đổi công vi ệc 
không ch ỉ chờ công vi ệc đang th ực thi có yêu c ầu nhập/xuất, mà khi công 
việc đang th ực thi h ết thời gian quy đ ịnh sử dụng CPU thì vi ệc chuy ển đổi 
công vi ệc cũng s ẽ xảy ra. M ỗi công vi ệc đƣợc thực hiện luân phiên qua cơ 
chế chuyển đổi CPU.  
 
Hình 1.3. CPU ph ục vụ các công vi ệc trong m ột hệ thống chia s ẻ thời gian  
Hệ điều hành chia s ẻ thời gian cho phép nhi ều ngƣ ời sử dụng chia s ẻ máy 
tính m ột cách đ ồng bộ do th ời gian chuy ển đổi rất nhanh nên h ọ có cảm giác 
là các ti ến trình đ ang đƣ ợc thi hành cùng lúc.  
Hệ điều hành chia s ẻ phức tạp hơn h ệ điều hành đa chƣơng. Nó ph ải có các 
chức năng: qu ản trị và bảo vệ bộ nhớ, sử dụng bộ nhớ ảo, cung c ấp hệ thống 
tập tin truy xu ất online, …  
Hệ điều hành chia s ẻ thời gian là ki ểu của các h ệ điều hành hi ện đại ngày 
nay.  
2.1.4.  Hệ thống song song (Parallel System)  
Hệ thống song song là h ệ thống có nhi ều bộ xử lý cùng chia s ẻ hệ thống 
đƣờng truy ền dữ liệu, đồng hồ, bộ nhớ và các thi ết bị ngoại vi. Các b ộ xử lý 
này liên l ạc bên trong v ới nhau.  
Ƣu đi ểm của hệ thống đa x ử lý:  
 Tin c ậy hơn h ệ thống đơn x ử lý do s ự hỏng hóc c ủa một bộ xử lý sẽ không 
ảnh hƣ ởng đến toàn h ệ thống.  
  
  
  
  
  
  
  
Tác v ụ 
  
Thời gian  
  
C 
  
B 
  
A
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  5   Hệ thống sẽ thực hiện nhanh hơn do các công vi ệc hoặc các chƣơng trình 
có th ể thực hiện đồng th ời trên nhi ều bộ xử lý khác nhau.  Nhƣng không có 
nghĩa là có n b ộ xử lý thì h ệ thống ho ạt động nhanh hơn n l ần.  
 Việc liên l ạc giữa các công vi ệc dễ dàng do cùng chia s ẻ bộ nhớ, thiết bị, 
… 
Hệ thống đa x ử lý thƣ ờng chia thành 2 lo ại:  
a) Đa x ử lý đối xứng (Symmetric MultiProcessing)  
Mỗi bộ xử lý ch ạy với một bản sao c ủa hệ điều hành, nh ững bản sao này liên 
lạc với nhau khi c ần thiết. Các h ệ điều hành máy cá nhân hi ện nay thƣ ờng hỗ 
trợ SMP.  
 
Hình 1.4. Mô hình h ệ thống song song  
b) Đa x ử lý bất đối xứng (Asymmetric Multiprocessing)  
Mỗi bộ xử lý đƣ ợc giao m ột công vi ệc riêng bi ệt, một bộ xử lý chính ki ểm 
soát toàn b ộ hệ thống. Mô hình này theo d ạng quan h ệ chủ tớ (Master – 
Slave). B ộ xử lý chính s ẽ lập lịch cho các b ộ xử lý còn l ại.  
2.1.5.  Hệ thống phân tán (Distributed System)  
Các b ộ xử lý khô ng chia s ẻ bộ nhớ và đồng hồ mà m ỗi bộ xử lý sẽ có bộ nhớ 
cục bộ riêng. Các b ộ xử lý trong h ệ thống phân tán thƣ ờng khác nhau v ề kích 
thƣớc và ch ức năng. Chúng th ực hiện trao đ ổi thông tin v ới nhau thông qua 
các đƣ ờng truy ền bus t ốc độ cao hay đƣ ờng dây đi ện tho ại,…. Công vi ệc xử 
lý sẻ đƣợc phân ph ối trên các b ộ xử lý trong h ệ thống phân tán.  
Ƣu đi ểm của hệ thống phân tán:  
 Chia s ẻ tài nguyên  
 Tăng t ốc độ tính toán  
 An toàn  
 Thông tin liên l ạc
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  6  Phân lo ại hệ thống phân tán:  
 Peer – to – peer: h ệ thống m ạng ngang hàng, các máy tính ngang c ấp 
nhau, không có máy nào đóng vai trò qu ản lý chung.  
 Client – server: có m ột hoặc nhi ều máy đóng vai trò qu ản lý các tài 
nguyên dùng chung g ọi là máy ch ủ (server), các máy khác g ọi là máy 
khách (client). Client mu ốn sử dụng tài nguyên dùng chung ph ải đƣợc 
server c ấp quy ền.  
 
Hình 1.5. Mô hình h ệ thống phân tán  
2.1.6.  Hệ thống xử lý th ời gian th ực (Real Time System)  
Đƣợc sử dụng khi có nh ững đòi h ỏi khắt khe v ề thời gian trên các thao tác 
của bộ xử lý ho ặc dòng d ữ liệu, thƣ ờng đƣợc dùng đi ều khi ển thi ết bị trong 
các ứng dụng tận hiến (Dedicated) nhƣ: tính toán khoa h ọc, hệ thống hình 
ảnh y khoa, h ệ thống đi ều khi ển công nghi ệp,…  
Hiện có hai lo ại hệ thống xử lý thời gian th ực là:  
a) Hệ thống th ời gian th ực cứng (Hard Real Time Syst em)  
Công vi ệc phải đƣợc hoàn t ất đúng lúc, d ữ liệu thƣ ờng đƣ ợc lƣu trong b ộ 
nhớ ngắn hạn hay ROM.  
b) Hệ thống th ời gian th ực mềm (Soft Real Time System)  
Mỗi công vi ệc có đ ộ ƣu tiên riêng và s ẽ đƣợc thi hành theo đ ộ ƣu tiên đó. 
Đƣợc sử dụng trong các ứng dụng multimedia, th ực tại ảo.  
2.1.7.  Hệ thống nhúng (Embedded Systems)  
Hệ điều hành đƣ ợc nhúng trong các thi ết bị: điện gia d ụng, máy trò chơi, 
điện tho ại, xe máy, …
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  7  Đặc trƣng c ủa hệ thống nhúng là tài nguyên h ạn chế (bộ nhớ, tốc độ xử lý, 
kích thƣ ớc màn hình, … ) do đó h ệ điều hành lo ại này c ần đơn gi ản, nh ỏ gọn, 
có tính đ ặc trƣng cho t ừng thi ết bị. 
TÓM T ẮT CHƢƠNG  
 Hệ điều hành là chƣơng trình trung gian gi ữa phần cứng và ngƣ ời sử dụng.  
 Hệ điều hành ph ải quản lý ph ần cứng, sau đó cung c ấp lại những giao ti ếp ảo 
cho ph ần mềm ứng dụng  
 Mục tiêu c ủa hệ điều hành là ph ải làm cho máy tính d ễ sử dụng hơn . 
 Có nhi ều loại hệ điều hành  
o Hệ thống xử lý theo lô đơn gi ản  
o Hệ thống xử lý theo lô đa chƣơng  
o Hệ thống chia s ẻ thời gian  
o Hệ thống song song  
o Hệ thống phân  tán  
o Hệ thống th ời gian th ực  
o Hệ thống nhúng  
 Xu hƣ ớng hi ện tại là các h ệ thống song song, phân tán  
BÀI T ẬP  
1) Giải thích s ự cần thiết phải có c ủa hệ điều hành trên máy tính.  
2) Trình bày m ục đích chung c ủa các h ệ điều hành.  
3) Phân bi ệt giữa hệ thống xử lý theo lô đa chƣơng và h ệ thống chia s ẻ thời gian.  
4) Phân bi ệt giữa hệ thống song song và h ệ thống phân tán.  
5) Mô t ả những ứng dụng th ực tế của hệ thống th ời gian th ực.  
6) Mô t ả những ứng dụng th ực tế của hệ thống nhúng.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  8  CHƢƠNG 2. GIAO DI ỆN LẬP TRÌNH VÀ XÂY D ỰNG H Ệ 
ĐIỀU HÀNH  
2.1. CÁC THÀNH PH ẦN CỦA HỆ THỐNG 
2.1.1.  Quản lý ti ến trình  
Tiến trình là m ột chƣơng trình đang đƣ ợc thi hành. H ệ điều hành ph ải tạo lập 
và duy trì ho ạt động của các ti ến trình. Đ ể hoàn t ất tác v ụ, một tiến trình 
thƣờng đòi h ỏi một số tài nguyên n ào đó nhƣ CPU, b ộ nhớ, thiết bị 
nhập/xuất,… Các tài nguyên này s ẽ đƣợc cấp phát cho ti ến trình vào th ời 
điểm tiến trình đƣ ợc tạo lập hay trong th ời gian ti ến trình ho ạt động. Khi ti ến 
trình k ết thúc h ệ điều hành c ần thu h ồi lại các tài nguyên đã c ấp phát c ho tiến 
trình đ ể tái sử dụng… Hơn n ữa, mỗi tiến trình là m ột đơn v ị tiêu th ụ thời 
gian s ử dụng CPU, do v ậy trong môi trƣ ờng đa nhi ệm, để đáp ứng nhu c ầu 
xử lý đồng hành, h ệ điều hành còn ph ải đảm nhi ệm việc phân ph ối CPU cho 
các ti ến trình m ột cách h ợp lý. Ngoài ra h ệ điều hành cũng c ần cung c ấp các 
cơ ch ế giúp các ti ến trình có th ể trao đ ổi thông tin và đ ồng bộ hóa ho ạt động 
của chúng.  
Tóm l ại, bộ phận quản lý ti ến trình ph ụ trách các công vi ệc sau đây:  
 Tạo lập, hủy bỏ một tiến trình.  
 Tạm dừng (suspend) , tái kích ho ạt (resume) m ột tiến trình.  
 Cung c ấp các cơ ch ế trao đ ổi thông tin gi ữa các ti ế
 ấp 
cơ ch ế đồng bộ hóa các ti ến trình  
2.1.2.  Quản lý b ộ nhớ chính  
Bộ nhớ chính là thi ết bị lƣu tr ữ duy nh ất mà CPU có th ể truy xu ất trực tiếp. 
Một chƣơng trình c ần đƣợc nạp vào b ộ nhớ chính và chuy ển đổi các đ ịa chỉ 
thành đ ịa chỉ tuyệt đối để CPU truy xu ất trong quá trình x ử lý. Đ ể tăng hi ệu 
suất sử dụng CPU, các h ệ thống đa nhi ệm cố gắng gi ữ nhiều tiến trình trong 
bộ nhớ chính t ại một thời điểm.  
Bộ phận quản lý b ộ nhớ cần đảm nhi ệm các công vi ệc sau:  
 Cấp phát và thu h ồi một vùng nh ớ cho ti ến trình khi c ần thiết.  
 Ghi nh ận tình tr ạng bộ nhớ chính: ph ần nào đã đƣ ợc cấp phát, ph ần nào 
còn có th ể sử dụng,…  
 Quyết định tiến trình nào đƣ ợc nạp vào b ộ nhớ chính khi có m ột vùng 
nhớ trống.  
2.1.3.  Quản lý b ộ nhớ phụ 
Những chƣơng trình cùng v ới dữ liệu của chúng ph ải đƣợc đặt trong b ộ nhớ 
chính trong quá trình thi hành. Nhƣng b ộ nhớ chính quá nh ỏ để có th ể lƣu 
giữ mọi dữ liệu và chƣơng trình, ngoài ra thông tin còn b ị mất khi không còn 
đƣợc cung c ấp năng lƣ ợng. H ệ thống máy tính ngày nay s ử dụng hệ thống
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  9  lƣu tr ữ phụ (thƣờng là đĩa). H ầu nhƣ t ất cả các chƣơng trình đ ều đƣợc lƣu tr ữ 
trên đĩa cho đ ến khi nó đƣ ợc thực hiện, nạp vào trong b ộ nhớ chính và cũng 
sử dụng đĩa đ ể chứa dữ liệu và k ết quả xử lý. Vì v ậy một hệ thống đĩa r ất 
quan tr ọng cho h ệ thống máy tính, t ốc độ của hệ thống máy tính ph ụ thuộc 
rất nhiều vào t ốc độ truy xu ất đĩa.  
Vai trò c ủa hệ điều hành trong qu ản lý đĩa:  
 Quản lý vùng tr ống trên đĩa.  
 Định vị lƣu tr ữ.  
 Lập lịch cho đĩa  
2.1.4.  Quản lý nh ập xuất 
Một trong nh ững m ục tiêu c ủa hệ điều hành là che d ấu những đặc thù c ủa các 
thiết bị phần cứng đối với ngƣ ời sử dụng. Thay vào đó là m ột lớp thân thi ện 
hơn, ngƣ ời sử dụng dễ thao tác hơn.  
Một hệ thống nh ập xuất bao g ồm:  
 Hệ thống buffer caching.  
 Giao ti ếp điều khi ển thiết bị (device driver) t ổng quát.  
 Bộ điều khi ển cho các thi ết bị phần cứng cụ thể.  
Chỉ có device driver m ới hiểu đến cấu trúc đ ặc thù c ủa thiết bị mà nó mô t ả.  
2.1.5.  Quản lý t ập tin  
Máy tính có th ể lƣu tr ữ thông tin trên nhi ều loại thiết bị lƣu tr ữ vật lý khác 
nhau, m ỗi thiết bị này có nh ững tính ch ất và t ổ chức vật lý đ ặc trƣng. Nh ằm 
cho phép s ử dụng ti ện lợi hệ thống thông tin, h ệ điều hành đƣa ra m ột khái 
niệm trừu tƣợng đồng nh ất cho t ất cả các thi ết bị lƣu trữ vật lý b ằng cách đ ịnh 
nghĩa m ột đơn v ị lƣu tr ữ là m ột tập tin. H ệ điều hành thi ết lập mối liên h ệ 
tƣơng ứng gi ữa tập tin và thi ết bị lƣu tr ữ vật lý ch ứa nó. Đ ể có th ể dễ dàng truy 
xuất, hệ điều hành còn t ổ chức tập tin thành các thƣ m ục. Ngoài ra, h ệ điều 
hành còn trách nhi ệm kiểm soát vi ệc truy c ập đồng th ời đến cùng m ột tập tin.  
Nhƣ v ậy, hệ điều hành ch ịu trách nhi ệm về các thao tác liên quan đ ến tập tin 
nhƣ:  
 Tạo lập, hủy bỏ một tập tin.  
 Tạo lập, hủy bỏ một thƣ m ục.  
 Cung c ấp thao tác x ử lý tập tin và thƣ m ục.  
 Tạo lập quan h ệ tƣơng ứng gi ữa tập tin và b ộ nhớ phụ chứa nó.  
2.1.6.  Hệ thống bảo vệ 
Khi h ệ thống cho phép nhi ều ngƣ ời sử dụng đồng th ời, các ti ến trình đ ồng hành 
cần phải đƣợc bảo vệ lẫn nhau đ ể tránh s ự xâm ph ạm vô tình hay c ố ý có th ể gây
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  10  sai lạc cho toàn h ệ thống. H ệ điều hành c ần xây d ựng các cơ ch ế bảo vệ cho 
phép đ ặc tả sự kiểm soát và m ột phƣơng cách đ ể áp dụng các chi ến lƣợc bảo vệ 
thích h ợp. 
2.1.7.  Quản lý m ạng 
Một hệ thống phân tán bao g ồm nhi ều bộ xử lý cùng chia s ẻ thông tin v ới nhau. 
Mỗi bộ xử lý có m ột bộ nhớ cục bộ, các ti ến trình trong h ệ thống có th ể đƣợc 
kết nối với nhau qua m ạng truy ền thông. H ệ thống phân tán cho phép ngƣ ời 
dùng truy c ập đến nhi ều tài nguyên h ệ thống khác nhau.  
2.1.8.  Hệ thông d ịch lệnh 
Đây là m ột trong nh ững bộ phận quan tr ọng nh ất của hệ điều hành, đóng vai trò 
giao ti ếp giữa hệ điều hành và ngƣ ời sử dụng. Các l ệnh đƣ ợc chuy ển đến hệ 
điều hành dƣ ới dạng các ch ỉ thị điều khi ển. Chƣơng trình shell – bộ thông d ịch 
lệnh – có nhi ệm vụ là nh ận lệnh và thông d ịch lệnh đó đ ể hệ điều hành có x ử lý 
tƣơng ứng. 
2.2. CÁC D ỊCH V Ụ CỦA HỆ ĐIỀU HÀNH (SYSTEM SERVICES)   
Hệ điều hành cung c ấp môi trƣ ờng để thi hành các chƣơng trình, b ằng cách cung 
cấp các d ịch vụ cho chƣơng trình và ngƣ ời sử dụng. Các d ịch vụ này trên m ỗi hệ 
thống là khác nhau nhƣn g cũng có nh ững lớp chung. Các d ịch vụ này giúp l ập 
trình viên thu ận tiện hơn và vi ệc lập trình d ễ dàng hơn.  
 Thi hành chƣơng trình  
Hệ thống ph ải có kh ả năng n ạp chƣơng trình vào b ộ nhớ và thi hành nó. 
Chƣơng trình ph ải chấm dứt thi hành theo cách thông t hƣờng hay b ất 
thƣờng (có l ỗi).  
 Thao tác nh ập xuất  
Một chƣơng trình thi hành có th ể yêu c ầu nhập xuất. Nh ập xuất này có th ể 
là tập tin hay thi ết bị. Để tăng hi ệu quả, ngƣ ời sử dụng không truy xu ất 
trực tiếp các thi ết bị nhập xuất mà thông qua cách th ức do hệ điều hành 
cung c ấp.  
 Thao tác trên h ệ thống tập tin  
Chƣơng trình có th ế yêu c ầu đọc, ghi, xóa, đ ổi tên, tìm ki ếm, cấp quy ền 
cho t ập tin, thƣ m ục. Đa s ố hệ điều hành cung c ấp nhi ều loại hệ thống file, 
có th ể cho ngƣ ời dùng ch ọn lựa hoặc bắt buộc tùy th eo yêu c ầu.  
 Thông tin  
Việc trao đ ổi thông tin có th ể đƣợc thực hiện giữa các ti ến trình trên cùng 
máy tính ho ặc giữa các h ệ thống khác nhau trong m ạng. Đƣ ợc thực hiện 
thông qua cơ ch ế vùng nh ớ chia s ẻ hoặc chuy ển thông đi ệp.  
 Phát hi ện lỗi
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  11  Hệ điều hành phải đảm bảo việc tính toán chính xác thông qua vi ệc phát 
hiện các l ỗi do ph ần cứng (CPU, b ộ nhớ, thiết bị nhập xuất) ho ặc chƣơng 
trình c ủa ngƣ ời dùng.  
 Giao di ện ngƣ ời dùng  
Có nhi ều dạng: dòng l ệnh (CLI – Command -Line Interface), x ử lý theo lô 
(Batch Int erface), giao di ện đồ họa (GUI – Graphical User Interface). 
Trong đó d ạng GUI đƣ ợc sử dụng nhi ều nhất, một số hệ thống còn cung 
cấp nhi ều loại giao di ện.  
2.3. LỜI GỌI HỆ THỐNG ( SYSTEM  CALL)  
Lời gọi hệ thống cung c ấp một giao ti ếp giữa tiến trình và h ệ điều hành. L ời gọi 
này cũng nhƣ các l ệnh hợp ngữ.  
Một số hệ thống cho phép l ời gọi hệ thống đƣ ợc thực hiện từ cấp lập trình ngôn 
ngữ cấp cao nhƣ các hàm và l ời gọi hàm. Nó có th ể phát sinh l ời gọi từ các th ủ 
tục hay g ọi trực tiếp trong dòng (inline).  
Có 3 phƣơn g pháp đƣ ợc sử dụng để chuy ển tham s ố cho h ệ điều hành:  
 Chuy ển tham s ố vào thanh ghi.  
 Lƣu gi ữ trong m ột bảng trong b ộ nhớ và địa chỉ của bảng này đƣ ợc 
truyền thông qua thanh ghi.  
 Dùng cơ ch ế Stack.  
 
Hình 2.1. Truy ền tham s ố dạng b ảng
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  12  
 
Hình 2.2. M ột số lời gọi hệ thống trong Windows và UNIX  
2.4. CÁC CHƢƠNG TRÌNH H Ệ THỐNG 
Các chƣơng trình h ệ thống cung c ấp một môi trƣ ờng ti ện lợi hơn cho vi ệc xây 
dựng và thi hành chƣơng trình. Nó có th ể chia thành m ột số loại nhƣ:  
 Thao tác v ới tập tin  
 Thông tin tr ạng thái   
 Mô t ả tập tin  
 Hỗ trợ ngôn ng ữ lập trình  
 Nạp và thi hành chƣơng trình  
 Thông tin  
 Các chƣơng trình ứng dụng  
Người sử dụng, các chương trình h ệ thống  
 
 Batch  Command -Line  
 
GUI 
  
  
Giao di ện ngư ời dùng
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  13   
 
 
Hình 2.3. T ổng quát thi ết kế hệ thống  
TÓM T ẮT CHƢƠNG  
 Hệ điều hành đƣ ợc thiết kế bao g ồm nhi ều thành ph ần hệ thống ph ối hợp với nhau 
để hoạt động.  
 Có nhi ều loại dịch vụ đƣợc cung c ấp cho ngƣ ời dùng, ph ần mềm ứng dụng.  
 Các dịch vụ đƣợc khai thác thông qua nh ững lời gọi hệ thống.  
BÀI T ẬP  
1) Nêu m ục đích c ủa bộ nhớ đệm (buffer) trong h ệ thống nh ập xuất.  
2) Trình đi ều khi ển thiết bị (device driver) do hãng nào cung c ấp? 
 
 
 
 
 
 
 
Lời gọi hệ thống 
  
  
  
  
  
  
  
  
  
  
  
Hệ điều hành  
  
  
  
  
  
  
  
  
Dịch vụ hệ thống 
  
Thi hành  
  
chương trinh  
  
Thao tác  
nhập xuất 
  
Hệ thống file  
  
 Thông tin  
  
Cấp phát  
  
tài nguyên  
  
Bảo vệ 
  
  
& bảo mật 
  
Phát hi ện lỗi 
  
Phần cứng
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  14  CHƢƠNG 3. C ẤU TRÚC H Ệ ĐIỀU HÀNH  
3.1. CẤU TRÚC H Ệ THỐNG 
3.1.1.  Cấu trúc đơn gi ản (Monolithique)  
Hệ điều hành là m ột tập hợp các th ủ tục, có th ể gọi lẫn nhau . Một số hệ 
monolithique cũng có th ể có m ột cấu trúc t ối thiểu khi phân chia các th ủ tục 
trong h ệ thống thành 3 c ấp độ:  
 Chƣơng trình chính (chƣơng trình c ủa ngƣ ời sử dụng) g ọi đến một thủ 
tục của hệ điều hành, đƣ ợc gọi là lời gọi hệ thống.  
 Tập hợp các th ủ tục dịch vụ (service) x ử lý nh ững lời gọi hệ thống. 
 Tập hợp các th ủ tục tiện ích (utility) h ỗ trợ các th ủ tục dịch vụ xử lý 
những lời gọi hệ thống.  
 
Ví dụ  
 
Khuy ết điểm  
 Không có s ự che d ấu dữ liệu, mỗi thủ tục có th ể gọi đến tất cả các th ủ 
tục khác.  Các m ức độ phân chia th ủ tục nếu có cũng không rõ r ệt, 
chƣơng trình ứng dụng có th ể truy xu ất đến các th ủ tục cấp thấp, tác 
động đến cả phần cứng, do v ậy hệ điều hành khó ki ểm soát và b ảo vệ 
hệ thống.  
 Hệ thống th ủ tục chỉ mang tính ch ất tĩnh, ch ỉ đƣợc kích ho ạt khi c ần 
thiết, do v ậy hệ điều hành thi ếu ch ủ động trong vi ệc qu ản lý môi 
trƣờng.  
Hình 3.1.C ấu trúc m ột hệ monolithique  
   
Thủ tục chính  
  
  
Thủ tục dịch vụ 
  
  
Thủ tục tiện ích  
  
  
Chương trình ứng dụng 
  
Chương trình thư ờng trú  
  
MS 
- 
DOS  
  
Phần cứng 
  
Hình 3.2. C ấu trúc của hệ điều hành MS -DOS
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  15  3.1.2.  Cấu trúc phân l ớp (Layered)  
Đơn th ể hóa h ệ thống bằng cách c ắt hệ thống thành m ột số lớp, mỗi lớp đƣợc 
xây d ựng dựa trên các l ớp bên trong. L ớp trong cùng (l ớp 0) thƣ ờng là ph ần 
cứng, lớp ngoài cùng (l ớp N) thƣ ờng là giao di ện với ngƣ ời sử dụng.  
Mỗi lớp là m ột đối tƣợng tr ừu tƣợng bao b ọc bên trong nó các d ữ liệu và 
thao tác x ử lý các d ữ liệu đó. L ớp N ch ứa đựng m ột số cấu trúc d ữ liệu và 
một số thủ tục có th ể đƣợc gọi bởi những lớp bên ngoài và l ớp N có th ể gọi 
những th ủ tục của các l ớp bên trong N.  
 
 
Ví dụ  
Cấu trúc c ủa hệ điều hành THE (Technische Hogeschool Eidhoven)  
 Lớp 5: chƣơng trình ứng dụng  
 Lớp 4: qu ản lý b ộ đệm cho thi ết bị nhập xuất  
 Lớp 3: trình đi ều khiển thao tác console  
 Lớp 2: qu ản lý b ộ nhớ  
 Lớp 1: đi ều phối CPU  
 Lớp 0: ph ần cứng  
  
  
  
  
  
  
  
  
  
  
  
Hình 3.3. Mô hình c ấu trúc 
phân l ớp 
  
Lớp 0 
Phần cứng 
Lớp 0 
  
Phần cứng 
  
Lớp 1 
  
… 
  
Lớp N 
  
Giao di ện ngư ời dùng  
  
  
 
Hình 3.4.M ột lớp của hệ điều hành phân l ớp 
   
Lớp N 
  
Thao tác m ới 
  
Thao tác đã có  
  
T 
hao tác  
  
nội bộ 
  
Lớp N 
  
- 
1
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  16  Ưu đi ểm  
Cho phép xây d ựng hệ thống mang tính đơn th ể, điều này giúp đơn gi ản việc tìm 
lỗi và ki ểm ch ứng hệ thống, vi ệc thiết kế và cài đ ặt đơn gi ản.  
Khuy ết điểm  
 Khó có  thể xác đ ịnh các l ớp một cách đ ầy đủ: bao nhiêu l ớp? M ỗi lớp đảm 
nhiệm nh ững ch ức năng gì? Do m ỗi lớp chỉ có th ể sử dụng các l ớp bên 
trong nên th ứ tự xếp đặt các l ớp cần phải đƣợc cân nh ắc cẩn thận.  
 Khi cài đ ặt thực tế, các h ệ thống theo c ấu trúc phân l ớp có khuynh hƣ ớng 
hoạt động kém hi ệu quả do m ột lời gọi thủ tục có th ể kích ho ạt lan truy ền 
các th ủ tục khác ở các l ớp bên trong, vì th ế tổng chi phí đ ể truyền tham s ố, 
chuy ển đổi ngữ cảnh,… tăng lên. H ậu qu ả là lời gọi hệ thống trong h ệ 
thống phân l ớp đƣợc thực hiện chậm hơn trong các h ệ thống không phân 
lớp.  
3.1.3.  Máy ảo (Virtual Machine)  
Phần nhân c ủa hệ thống là trình t ổ chức giám sát máy ảo (monitor of virtual 
machine) ch ịu trách nhi ệm giao ti ếp với phần cứng và cho phép kh ả năng đa 
chƣơng b ằng cách cung c ấp nhi ều máy ảo cho các l ớp bên trên. Các máy ảo 
không ph ải là các máy tính m ở rộng mà là b ản sao ( ảo) chính xác các đ ặc 
tính ph ần cứng của máy tính th ật sự và cho phép m ột hệ điều hành khác ho ạt 
động trên nó nhƣ trên ph ần cứng th ực sự, các h ệ điều hành nà y mới là thành 
phần chịu trách nhi ệm cung c ấp cho ngƣ ời sử dụng m ột máy tính m ở rộng. 
Hơn n ữa, mỗi máy ảo có th ể cho phép m ột hệ điều hành khác nhau ho ạt động 
trên nó, nhƣ v ậy có th ể tạo ra nhi ều môi trƣ ờng đồng th ời trên m ột máy tính 
thật sự.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  17  Hình 3.5 . Mô hình h ệ thống máy ảo 
Ưu đi ểm  
 Trong môi trƣ ờng này, các tài nguyên h ệ thống đƣ ợc bảo vệ hoàn toàn vì 
mỗi máy ảo là đ ộc lập với các máy ảo khác.  
 Sự phân tách hoàn toàn s ự đa chƣơng và máy tính m ở rộng dẫn đến một hệ 
thống m ềm dẻo linh đ ộng hơn và d ễ bảo trì hơn.  
 Việc tạo lập các máy ảo đã cung c ấp một phƣơng ti ện để giải quy ết vấn đề 
tƣơng thích: m ột chƣơng trình đƣ ợc phát tri ển trên h ệ điều hành X có th ể 
hoạt động trong môi trƣ ờng máy ảo X trên m ột máy tính th ật sự sử dụng 
hệ điều hành Y.  
Khuy ết điểm  
Việc cài đ ặt các ph ần mềm giả lập phần cứng thƣ ờng rất khó khăn.  
3.1.4.  Mô hình Client – Server (Microkernel)  
Xu hƣ ớng chung c ủa các h ệ điều hành hi ện đại là chuy ển dần các tác v ụ của 
hệ điều hành ra nh ững lớp bên ngoài, thu nh ỏ phần cốt lõi c ủa hệ điều hành  
thành h ạt nhân c ực tiểu (microkernel) sao cho ch ỉ phần hạt nhân này là ph ụ 
thuộc phần cứng. M ột cách ti ếp cận phổ biến là c ấu trúc h ệ thống theo mô 
hình Client – Server.   
Trong mô hình Client -Server, các thành ph ần không c ần thiết sẽ đƣợc đƣa ra 
khỏi hạt nhân c ủa hệ điều hành và ch ạy nhƣ m ột tiến trình server ở chế độ 
không đ ặc quy ền (user -mode). Ph ần hạt nhân h ệ điều hành s ẽ đảm nhi ệm 
việc tạo cơ ch ế thông tin liên l ạc giữa các ti ến trình client và ti ến trình server. 
Khi đó các ti ến trình trong h ệ thống có th ể chia thành 2 lo ại:   
 Tiến trình c ủa ngƣ ời dùng (client)  
 Tiến trình c ủa hệ điều hành (server)  
Khi c ần thực hiện một chức năng c ủa hệ thống, ti ến trình client s ẽ gởi yêu 
cầu đến tiến trình server tƣơng ứng, ti ến trình server s ẽ xử lý yêu c ầu và h ồi 
đáp cho ti ến trình client. Liên l ạc giữa 2 ti ến trình đƣ ợc thực hiện thông qua 
hạt nhân c ủa hệ điều hành.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  18   
  
Hình 3.6.  Mô hình Client – Server  
Ưu đi ểm  
 Hạt nhân r ất nhỏ, chỉ gồm các ph ần cơ b ản, nên d ễ bảo vệ, nâng c ấp.  
 Dễ mở rộng và s ửa đổi hệ điều hành thông qua vi ệc mở rộng và s ửa đổi 
các ti ến trình server.  
 Các ti ến trình server c ủa hệ điều hành ho ạt động trong ch ế độ không đ ặc 
quyền nên không th ể truy c ập trực tiếp tới phần cứng. Đi ều này giúp h ệ 
thống đƣ ợc bảo vệ tốt hơn nên tính ổn định và an nin h cao hơn.  
 Cấu trúc Client – Server r ất phù h ợp với hệ thống phân tán. Các ti ến trình 
Server có th ể chạy ở những hệ thống khác nhau.  
3.2. NGUYÊN LÝ THI ẾT KẾ HỆ ĐIỀU HÀNH  
 Hệ điều hành c ần dễ viết, dễ sửa lỗi, dễ nâng c ấp (hệ điều hành nên vi ết 
bằng ngôn ng ữ cấp cao, ch ỉ viết bằng hợp ngữ những ph ần thật cần thiết, 
vì ngôn ng ữ cấp cấp cao d ễ viết, dễ bảo trì hơn h ợp ngữ).  
 Hệ điều hành c ần dễ cài đ ặt, dễ bảo trì, không có l ỗi và hi ệu quả.  
 Hệ điều hành c ần dễ sử dụng, d ễ học, an toàn, có đ ộ tin cậy và th ực hiện 
nhanh.  
 Hệ điều hành c ần có tính kh ả chuy ển cao (th ực hiện đƣợc trên m ột nhóm 
các ph ần cứng khác nhau)  
 Hệ điều hành c ần có chƣơng trình SYSGEN (System Generation) thu th ập 
thông tin liên qua đ ến phần cứng để thiết lập cấu hình h ệ điều hành phù 
hợp với mỗi máy tính.  
  
Phần cứng 
  
  
  
  
  
  
  
  
Microkernel  
  
Giao ti ếp 
  
tiến trình  
  
Quản lý 
  
bộ nhớ 
  
Lập lịch 
  
CPU  
  
Phần mềm 
  
ứng dụng 
  
Hệ thống 
  
file 
  
Device  
  
Driver  
  
Thông đi ệp 
  
 Thông đi ệp 
  
User  
  
mode  
  
Kernel  
  
mode
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  19  TÓM T ẮT CHƢƠNG  
 Hệ điều hành đƣ ợc thiết kế bao g ồm nhi ều thành ph ần hệ thống ph ối hợp 
với nhau đ ể hoạt động.  
 Có nhi ều loại dịch v ụ đƣợc cung c ấp cho ngƣ ời dùng, ph ần mềm ứng 
dụng.  
 Các d ịch vụ đƣợc khai thác thông qua nh ững lời gọi hệ thống.  
 Các chƣơng trình h ệ thống đƣ ợc cung c ấp để đáp ứng nh ững yêu c ầu 
chung c ủa ngƣ ời dùng.  
 Mô hình máy ảo giúp tri ển khai đƣ ợc nhi ều hệ điều hành cùng lúc trên 
cùng m ột hệ thống.  
 Hầu hết các h ệ điều hành hi ện đại đƣợc thi ết kế theo mô hình Client – 
Server.  
BÀI T ẬP  
1) Mô t ả những ứng dụng của máy ảo trong th ực tế.  
2) Tìm hi ểu về hệ điều hành MS -DOS.  
3) Tìm hi ểu cấu trúc c ủa hệ điều hành Windows, Linux
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  20   
CHƢƠNG 4. FILE VÀ THAO TÁC FILE  
4.1. CÁC KHÁI NI ỆM CƠ B ẢN  
4.1.1.  Bộ nhớ ngoài  
Máy tính ph ải sử dụng thi ết bị có khả năng lƣu tr ữ dữ liệu trong th ời gian dài  
(long -term) vì:  
 Phải chứa những lƣ ợng thông tin r ất lớn (giữ vé máy bay, ngân hàng, …).  
 Thông tin ph ải đƣợc lƣu gi ữ trong m ột thời gian dài trƣ ớc khi x ử lý.  
 Nhiều tiến trình có th ể truy c ập cùng m ột lúc.  
Giải pháp là s ử dụng các thi ết bị lƣu tr ữ bên ngoài g ọi là b ộ nhớ ngoài.  
4.1.2.  Tập tin và thƣ m ục 
Tập tin  
Tập tin là đơn v ị lƣu tr ữ thông tin c ủa bộ nhớ ngoài. Các ti ến trình có th ể đọc 
hay t ạo mới tập tin n ếu cần thiết. Thông tin trên t ập tin là v ững bền khôn g bị 
ảnh hƣ ởng bởi các x ử lý tạo hay k ết thúc các ti ến trình, ch ỉ mất đi khi user th ật 
sự muốn xóa. T ập tin đƣ ợc quản lý b ởi hệ điều hành.  
Thư m ục  
Để lƣu tr ữ dãy các t ập tin, h ệ thống qu ản lý t ập tin cung c ấp thƣ m ục, mà trong 
nhiều hệ thống có th ể coi n hƣ là t ập tin.  
Hệ thống qu ản lý t ập tin  
Các t ập tin đƣ ợc quản lý b ởi hệ điều hành v ới cơ ch ế gọi là h ệ thống qu ản lý 
tập tin. Bao g ồm: cách hi ển thị, các y ếu tố cấu thành t ập tin, cách đ ặt tên, cách 
truy xu ất, cách s ử dụng và b ảo vệ tập tin, các thao tác  trên t ập tin. Cách t ổ 
chức thƣ m ục, các đ ặc tính và các thao tác trên thƣ m ục.  
4.2. MÔ HÌNH QU ẢN LÝ VÀ T Ổ CHỨC CÁC T ẬP TIN  
4.2.1.  Mô hình  
a) Tập tin  
Tên t ập tin  
Tập tin là m ột cơ ch ế trừu tƣợng và đ ể quản lý m ỗi đối tƣợng ph ải có m ột tên. 
Khi ti ến trình t ạo một tập tin, nó s ẽ đặt một tên, khi ti ến trình k ết thúc t ập tin 
vẫn tồn tại và có th ể đƣợc truy xu ất bởi các ti ến trình khác v ới tên t ập tin đó.  
Cách đ ặt tên t ập tin c ủa mỗi hệ điều hành là khác nhau, h ệ thống tập tin có th ể 
có hay không có phân bi ệt chữ thƣờng và ch ữ hoa. Nhi ều hệ thống tập tin h ỗ 
trợ tên tập tin g ồm ph ần đƣợc phân cách b ởi dấu “.” mà ph ần sau đƣ ợc gọi là 
phần mở rộng. H ệ điều hành dùng ph ần mở rộng để nhận dạng ki ểu của tập tin
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  21  và các thao tác có th ể thực hiện trên ki ểu tập tin đó. Ví d ụ: tập tin readme.txt  
trong Windows thì h ệ điều hành s ẽ hiểu là t ập tin văn b ản và liên k ết với một 
chƣơng trình x ử lý văn b ản khi m ở tập này.  
Cấu trúc c ủa tập tin gồm 3 lo ại:  
 Dãy tu ần tự các byte không c ấu trúc: h ệ điều hành không bi ết nội dung c ủa 
tập tin.  
 Dãy các record có chi ều dài c ố định.  
 Cấu trúc cây: g ồm cây c ủa những record, không c ần thiết có cùng đ ộ dài. 
Mỗi record có m ột trƣờng khóa giúp cho vi ệc tìm ki ếm nhanh hơn.  
Kiểu tập tin  
Các h ệ điều hành h ỗ trợ cho nhi ều loại tập tin khác nhau bao g ồm các  kiểu 
nhƣ: t ập tin thƣ ờng, thƣ m ục, tập tin có ký t ự đặc biệt, tập tin kh ối.  
 Tập tin thƣ ờng: là t ập tin text hay t ập tin nh ị phân ch ứa thông tin c ủa 
ngƣời sử dụng.  
 Thƣ m ục: là nh ững tập tin h ệ thống dùng đ ể lƣu gi ữ cấu trúc c ủa hệ thống 
tập tin.  
 Tập tin  có ký t ự đặc biệt: liên quan đ ến nhập xuất thông qua các thi ết bị 
nhập xuất tuần tự nhƣ màn hình, máy in, m ạng, …  
 Tập tin kh ối: dùng đ ể truy xu ất trên thi ết bị đĩa.  
Tập tin thƣ ờng đƣ ợc chia thành hai lo ại là tập tin văn b ản và t ập tin nh ị phân.  
 Tập tin văn b ản: ch ứa các dòng văn b ản, cu ối dòng có ký hi ệu enter. M ỗi 
dòng có đ ộ dài có th ể khác nhau. Ƣu đi ểm của kiểu tập tin này là nó có th ể 
hiển thị, in hay so ạn thảo với một editor thông thƣ ờng. Đa s ố các chƣơng 
trình dùng t ập tin văn b ản để nhập xuất, nó cũng d ễ dàng làm đ ầu vào và 
đầu ra cho cơ ch ế pipeline.  
 Tập tin nh ị phân: có c ấu trúc khác t ập tin văn b ản. M ặc dù v ề mặt kỹ thuật, 
tập tin nh ị phân g ồm dãy các byte, nhƣng h ệ điều hành ch ỉ thực thi t ập tin 
đó nếu nó có c ấu trúc đúng.  
Truy xu ất tập tin  
Trƣớc đây ch ỉ có m ột kiểu truy xu ất tập tin: tu ần tự. Tiến trình đ ọc tất cả các 
byte trong t ập tin theo th ứ tự từ đầu. Truy xu ất kiểu này thu ận lợi cho các lo ại 
băng t ừ. Đối với đĩa, vi ệc truy xu ất theo khóa hơn là v ị trí, các byte đƣ ợc đọc 
theo b ất kỳ vị trí nào  
Thuộc tính t ập tin  
Bao g ồm các thu ộc tính: b ảo vệ, mật khẩu, ngƣ ời tạo, ngƣ ời sở hữu, read only, 
hidden, system, archive, ASCII/Binary, truy xu ất ngẫu nhiên, lock, …
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  22  b) Thư m ục  
Hệ thống thƣ m ục theo c ấp bậc  
Số lƣợng thƣ m ục trên m ỗi hệ thống là khác nhau. Thi ết kế đơn gi ản nhất là h ệ 
thống ch ỉ có thƣ m ục đơn ch ứa tất cả các t ập tin c ủa tất cả ngƣời dùng. Cách 
này d ễ nhƣng s ẽ gây ra khó khăn khi có nhi ều ngƣ ời sử dụng vì s ẽ có nhi ều tập 
tin trùng tên. Cách th ứ hai là có m ột thƣ m ục gốc và trong  đó có nhi ều thƣ m ục 
con, trong m ỗi thƣ m ục con ch ứa tập tin c ủa ngƣ ời sử dụng, cách này tránh 
đƣợc trƣ ờng h ợp xung đ ột tên nhƣng cũng còn khó khăn v ới ngƣ ời dùng có 
nhiều tập tin. Ngƣ ời sử dụng luôn mu ốn nhóm các ứng dụng lại một cách logic. 
Từ đó, h ệ thống thƣ m ục theo c ấp bậc đƣợc hình thành v ới mô hình m ột thƣ 
mục có th ể chứa tập tin ho ặc một thƣ m ục con và c ứ tiếp tục nhƣ v ậy hình thành 
cây thƣ m ục.  
  
Hình 4.1. H ệ thống thư m ục đơn c ấp  
  
Hình 4. 2. Hệ thống thư m ục 2 c ấp
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  23   
Hình 4.3 . Hệ thống thư m ục theo c ấp bậc  
Đƣờng dẫn  
Khi m ột hệ thống tập tin đƣ ợc tổ chức thành m ột cây thƣ m ục, có hai cách đ ể 
xác đ ịnh tên m ột tập tin. Cách th ứ nhất là đƣ ờng dẫn tuy ệt đối, mỗi tập tin đƣ ợc 
gán m ột đƣờng dẫn từ thƣ m ục gốc đến tập tin. Ví d ụ: /usr/ast/mailbox.  
Dạng th ứ hai là đƣ ờng dẫn tƣơng đ ối, dạng này có liên quan đ ến một khái ni ệm 
là thƣ m ục hiện hành hay thƣ m ục làm vi ệc. Ngƣ ời sử dụng có th ể quy đ ịnh m ột 
thƣ m ục là thƣ m ục hiện hành. Khi đó, đƣ ờng dẫn không b ắt đầu từ thƣ m ục 
gốc mà liên quan đ ến thƣ m ục hiện hành. Ví d ụ: nếu thƣ m ục hiện hành là 
/usr/ast thì t ập tin v ới đƣờng dẫn tuy ệt đối /usr/ast/mailbox có th ể đƣợc dùng 
đơn gi ản là mailbox.  
Trong ph ần lớn hệ thống, m ỗi tiến trình có m ột thƣ m ục hiện hành riêng, khi 
một tiến trình thay đ ổi thƣ m ục làm việc và k ết thúc, không có s ự thay đ ổi để lại 
trên h ệ thống tập tin. Nhƣng n ếu một hàm thƣ vi ện thay đ ổi đƣờng dẫn và sau 
đó không đ ổi lại thì s ẽ có ảnh hƣ ởng đến tiến trình.  
Hầu hết các h ệ điều hành đ ều hỗ trợ hệ thống thƣ m ục theo c ấp bậc với hai 
entry đặc biệt cho m ỗi thƣ m ục là “.” và “..” . Trong đó “.” ch ỉ thƣ m ục hiện 
hành còn “..” ch ỉ thƣ m ục cha.  
4.2.2.  Các ch ức năng  
a) Tập tin  
Tạo: một tập tin đƣ ợc tạo chƣa có d ữ liệu. M ục tiêu c ủa chức năng này là thông 
báo cho bi ết rằng t ập tin đã t ồn tại và thi ết lập m ột số thuộc tính.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  24  Xóa:  khi m ột tập tin không còn c ần thiết nữa, nó đƣ ợc xóa đ ể tăng dung lƣ ợng 
đĩa. M ột số hệ điều hành t ự xóa t ập tin sau m ột kho ảng th ời gian n ngày.  
Mở: trƣớc khi s ử dụng m ột tập tin, ti ến trình ph ải mở nó. M ục tiêu c ủa mở là 
cho p hép h ệ thống thi ết lập một số thuộc tính và đ ịa chỉ đĩa trong b ộ nhớ để 
tăng t ốc độ truy xu ất.  
Đóng:  khi ch ấm dứt truy xu ất, thu ộc tính và đ ịa chỉ trên đĩa không c ần dùng 
nữa, tập tin đƣ ợc đóng l ại để giải phóng vùng nh ớ. Một số hệ thống hạn chế tối 
đa số tập tin m ở trong m ột tiến trình.  
Đọc: đọc dữ liệu từ tập tin t ại vị trí hi ện thời cảu đầu đọc, nơi g ọi sẽ cho bi ết 
cần bao nhiêu d ữ liệu và v ị trí của buffer lƣu tr ữ nó.  
Ghi:  ghi d ữ liệu lên t ập tin t ừ vị trí hi ện thời của đầu đọc. Nếu là cu ối tập tin, 
kích thƣ ớc tập tin s ẽ tăng lên, n ếu đang ở giữa tập tin, d ữ liệu sẽ bị ghi ch ồng 
lên.  
Thêm:  gần giống nhƣ ghi nhƣng d ữ liệu luôn đƣ ợc ghi vào cu ối tập tin.  
Tìm:  dùng đ ể truy xu ất tập tin ng ẫu nhiên.  
Lấy thu ộc tính:  lấy thu ộc tính c ủa tập tin hi ện hành.  
Thiết lập thu ộc tính:  thay đ ổi thu ộc tính c ủa tập tin sau m ột thời gian s ử 
dụng. 
Đổi tên:  thay đ ổi tên c ủa tập tin đã t ồn tại.  
b) Thư m ục  
Tạo: khi m ột thƣ mục đƣợc tạo, nó r ỗng, ngo ại trừ “.” và “..” đƣ ợc đặt tự 
động bởi hệ thống.  
Xóa:  xóa m ột thƣ m ục, chỉ có thƣ m ục rỗng m ới bị xóa, thƣ m ục chứa “.” và 
“..” coi nhƣ là thƣ m ục rỗng.  
Mở: thƣ m ục có th ể đọc đƣợc. Ví d ụ để liệt kê t ất cả tập tin trong m ột thƣ m ục, 
chƣơng trình li ệt kê s ẽ mở thƣ m ục và đ ọc tên c ủa tất cả các t ập tin ch ứa trong 
đó.  
Đóng:  khi một thƣ m ục đã đƣ ợc đọc xong, ph ải đóng thƣ m ục lại để giải phóng 
vùng nh ớ.  
Đọc: lệnh này tr ả về entry ti ếp theo trong thƣ m ục đã m ở. Thông thƣ ờng có th ể 
đọc thƣ m ục bằng lời gọi hệ thống READ, l ệnh đọc thƣ m ục luôn luôn tr ả về 
một entry dƣ ới dạng chu ẩn.  
Đổi tên:  cũng nhƣ t ập tin, thƣ m ục cũng có th ể đƣợc đổi tên.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  25  Liên k ết: kỹ thuật này cho phép m ột tập tin có th ể xuất hiện trong nhi ều thƣ 
mục khác nhau. Khi có yêu c ầu, m ột liên k ết sẽ đƣợc tạo giữa tập tin và m ột 
đƣờng dẫn đƣợc cung c ấp.  
Bỏ liên k ết: nếu tập tin ch ỉ còn liên k ết với một thƣ m ục, nó s ẽ bị loại bỏ hoàn 
toàn kh ỏi hệ thống, n ếu nhi ều thì nó ch ỉ bị giảm ch ỉ số liên k ết.  
  
Hình 4.4. Cấu trúc thƣ m ục có s ử dụng liên k ết 
4.3. CÀI Đ ẶT HỆ THỐNG QU ẢN LÝ T ẬP TIN  
4.3.1.   Giới thiệu  
Ngƣời sử dụng thì quan  tâm đ ến cách đ ặt tên t ập tin, các thao tác trên t ập tin, 
cây thƣ m ục, … Nhƣng đ ối với ngƣ ời cài đ ặt thì quan tâm đ ến tập tin và thƣ 
mục đƣợc lƣu tr ữ nhƣ th ế nào, vùng nh ớ trên đĩa đƣ ợc quản lý nhƣ th ế nào và 
làm sao cho toàn b ộ hệ thống làm vi ệc hữu hiệu và tin c ậy.  
Phân vùng (Partition)  
Hệ điều hành có th ể chia đĩa c ứng thành nhi ều phân vùng, m ỗi phân vùng 
gồm nhi ều từ trụ (cylinder) liên ti ếp, ho ặc tập hợp nhi ều đĩa c ứng thành m ột 
phân vùng. M ỗi phân vùng s ẽ có cấu trúc thƣ m ục riêng đ ể quản lý các t ập tin 
trong phân vùng đó.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  26    
Hình 4.4 . Tổ chức phân vùng đĩa  
 Bảng thư m ục (Directory table)  
Trƣớc khi t ập tin đƣ ợc đọc, tập tin ph ải đƣợc mở. Để mở tập tin, h ệ thống 
phải biết đƣờng d ẫn do ngƣ ời sử dụng cung c ấp và đƣ ợc định vị trong c ấu 
trúc directo ry entry. Directory entry cung c ấp các thông tin c ần thi ết để tìm 
kiếm các kh ối. Tùy thu ộc vào m ỗi hệ thống, thông tin là đ ịa chỉ trên đĩa c ủa 
toàn b ộ tập tin, s ố hiệu của khối đầu tiên, ho ặc là s ố i-node.  
 
 
 
 
 
 
Hình 4 .6. Một directory entry c ủa FAT (MS -DOS / Windows)  
 Bảng phân ph ối vùng nh ớ  
Nguyên t ắc là dùng đ ể lƣu tr ữ các kh ối trên đĩa c ấp phát cho t ập tin lƣu d ữ 
liệu.  
4.3.2.  Cài đ ặt bảng phân ph ối vùng nh ớ  
Định vị liên ti ếp  
Lƣu tr ữ tập tin trên dãy các kh ối liên ti ếp.  
Phƣơng pháp này có 2 ƣu đi ểm là d ễ dàng cài đ ặt và d ễ thao tác vì toàn b ộ tập tin 
đƣợc đọc từ đĩa b ằng thao tác đơn gi ản không c ần định vị lại.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  27  Phƣơng pháp này cũng có 2 khuy ết điểm: không linh đ ộng tr ừ khi bi ết trƣớc kích 
thƣớc tối đa c ủa tập tin. Gây ra s ự phân m ảnh trên đĩa, lãng phí l ớn.  
 
 Hình 4. 7. Cấp phát vùng nh ớ liên t ục  
 Định vị bằng danh sách liên k ết  
Mọi khối đều đƣ ợc cấp phát, không b ị lãng phí trong trƣ ờng hợp phân m ảnh và 
directory entry ch ỉ cần chứa địa chỉ của khối đầu tiên. Tuy nhiên kh ối dữ liệu sẽ bị thu 
hẹp lại và truy xu ất ngẫu nhiên s ẽ bị chậm
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  28   
I-nodes  
Một i-node bao g ồm hai ph ần. Ph ần thứ nhất là thu ộc tính c ủa tập tin. Ph ần thứ 
hai ch ứa địa chỉ của khối dữ liệu. Ph ần này chia thành hai ph ần nhỏ. Phần nhỏ thứ 
nhất bao g ồm 10 ph ần tử, mỗi phần tử chứa địa chỉ khối dữ liệu của tập tin. Ph ần tử 
thứ 11 ch ứa single indirect kh ối, chứa địa chỉ của một khối, trong kh ối đó ch ứa một 
bảng có đ ến 210 ph ần tử mà m ỗi phần tử mới chứa địa chỉ của khối dữ liệu. Ph ần tử 
thứ 12 ch ứa double indirect kh ối, chứa địa chỉ của bảng các single indirect kh ối. Phần 
tử thứ 13 là triple indirect kh ối.  
 
Hình 4. 9. I-node trong UNIX  
 
Hình 4.8.Định vị bằng danh sách liên k ết 
   
Khối  
tập  
tin 
  
0 
  
4 
  
Khối  
tập  
tin 
  
1 
  
7 
  
Khối  
tập  
tin 
  
2 
  
2 
  
Khối  
tập  
tin 
  
3 
  
10 
  
Khối  
tập  
tin 
  
4 
  
12 
  
Tập tin A  
  
Khối  
tập  
tin 
  
0 
  
6 
  
Kh 
ối  
tập  
tin 
  
1 
  
3 
  
Khối  
tập  
tin 
  
2 
  
11 
  
Khối  
tập  
tin 
  
3 
  
14 
  
Tập tin B  
  
Khối vật lý  
trên đĩa
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  29  4.3.3.   Quản lý các kh ối trống  
Có hai phƣơng pháp mà h ệ điều hành thƣ ờng sử dụng để quản lý các kh ối trống là 
sử dụng danh sách liên k ết hoặc vector bit  
Danh sách l iên k ết  
Mỗi nút trong danh sách liên k ết là m ột khối chứa một bảng gồm các s ố hiệu khối 
trống, ph ần tử cuối của bảng lƣu s ố hiệu khối tiếp theo trong danh sách.  
Ví dụ: giả sử khối đầu tiên trong danh sách liên k ết là kh ối 2. Trong kh ối 2 lƣu 
các s ố 75, 5 3, 70, 59 là các s ố hiệu khối trống. Kh ối 3 ch ứa bảng số hiệu các kh ối 
trống ti ếp theo… H ệ điều hành ch ỉ cần biết số hiệu khối đầu tiên c ủa danh sách liên 
kết.  
 
 
 
 
Ví dụ: một đĩa dung lƣ ợng 20MB, dùng kh ối có kích thƣ ớc 1KB. Đ ể quản lý đĩa 
này, n ếu đĩa h oàn toàn tr ống thì danh sách liên k ết cần bao nhiêu kh ối?  
20MB = 20.210 khối  ~ 215 khối -> cần dùng 16 bit (2 byte) đ ể lƣu m ột số hiệu khối  
 1 khối = 1024 byte lƣu đƣ ợc 511 s ố hiệu khối trống  
 Để quản lý đĩa có 20MB hoàn toàn tr ống, danh sách liên k ết cần   
20 x 210 / 511  ~ 40 kh ối  
Nhận xét: t ốn khá nhi ều khối nhớ cho danh sách liên k ết nếu đĩa hoàn toàn 
trống, nhƣng s ẽ ít tốn khối nhớ cho danh sách liên k ết nếu đĩa g ần đầy.  
  
  
  
  
0 
  
75 
  
1 
  
53 
  
2 
  
70 
  
3 
  
59 
  
4 
  
3 
  
0 
  
75 
  
1 
  
53 
  
2 
  
70 
  
3 
  
59 
  
4 
  
3 
  
Khối 2 
  
 Khối 3 
  
…
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  30    
Hình 4.10 . Quản lý kh ối trống sử dụng danh sách liên k ết  
Dùng vector bit  
Là m ột dãy các bit, trong đó bit th ứ i bằng 1 là kh ối thứ i còn tr ống, b ằng 0 là 
khối thứ i đã s ử dụng. Vector bit đƣ ợc lƣu trên m ột hoặc nhi ều khối đĩa, khi c ần sẽ 
đƣợc đọc vào b ộ nhớ để xử lý nhanh.  
Vector bit t ốn ít kh ối nhớ hơn danh sách liên k ết nhƣn g kích thƣ ớc vector là c ố 
định,  h ệ điều hành c ần đồng bộ vector bit trong b ộ nhớ và vector bit trên đĩa.  
Ví dụ: đĩa dung lƣ ợng 20MB, kh ối có kích thƣ ớc 1KB s ẽ có vector bit kích thƣ ớc 
là 20 x 210 bit  -> chiếm 20 x 1010 / 8 / 210 ~ 3KB (3 kh ối).  
4.3.4.  Quản lý khối hỏng  
Có 2 cách:  
 Lƣu danh sách các sector h ỏng trong m ột file trên đĩa  
 Dùng m ột sector trên đĩa đ ể lƣu danh sách các sector h ỏng  
Khi b ộ kiểm soát đĩa th ực hiện truy xu ất lần đầu tiên, nó đ ọc danh sách các kh ối 
hỏng vào b ộ nhớ, từ đó không cho truy  cập những kh ối đó n ữa.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  31  TÓM T ẮT CHƢƠNG  
 Tập tin là đơn v ị lƣu tr ữ thông tin cơ b ản trên đĩa.  
 Tập tin có th ể chứa chƣơng trình hay d ữ liệu, có th ể có cấu trúc ho ặc chỉ là 
một dãy các byte.   
 Tập tin có th ể đƣợc truy xu ất tuần tự hoặc ngẫu nhiên  
 Thƣ m ục dùng đ ể dể quản lý các t ập tin trên đĩa. Thƣ m ục thƣ ờng có c ấu 
trúc d ạng cấp bậc.  
 Hệ điều hành có th ể chia đĩa c ứng thành nhi ều phân vùng, m ỗi phân vùng 
sẽ có cấu trúc thƣ m ục riêng đ ể quản lý các t ập tin trong phân vùng đó.  
 Bảng thƣ m ục là m ột dạng cài đ ặt của cấu trúc thƣ m ục. Bảng thƣ m ục có 
nhiều mục, mỗi mục lƣu tr ữ thông tin mô t ả của một file.  
 Có nhi ều cách cài đ ặt bảng phân ph ối vùng nh ớ khác nhau: liên ti ếp, danh 
sách liên k ết, danh sách liên k ết sử dụng ch ỉ mục, i-nodes, …  
BÀI T ẬP  
1) Giải thích v ì sao c ần phân chia đĩa c ứng thành các phân vùng (partition)?  
2) Viết các chƣơng trình mô ph ỏng gi ải thuật cấp phát liên t ục.  
3) Viết các chƣơng trình mô ph ỏng gi ải thuật cấp phát theo danh sách liên k ết.  
4) Viết các chƣơng trình mô ph ỏng gi ải thuật cấp phát the o danh sách liên k ết sử 
dụng index.  
5) Tìm hi ểu cấu trúc b ảng FAT. Vi ết chƣơng trình truy xu ất thông tin tr ực tiếp 
trên b ảng FAT.  
6) Viết các chƣơng trình sau (có th ể sử dụng Pascal ho ặc C):  
a. Mô ph ỏng lệnh DIR c ủa DOS.  
b. Mô ph ỏng lệnh COPY c ủa DOS.  
c. Mô ph ỏng lệnh TREE c ủa DOS.  
d. Mô ph ỏng lệnh TYPE c ủa DOS.  
e. Mô ph ỏng lệnh DEL c ủa DOS.  
f. Mô ph ỏng lệnh MD c ủa DOS.  
g. Mô ph ỏng lệnh CD c ủa DOS.  
h. Mô ph ỏng lệnh RD c ủa DOS.  
i. Mô ph ỏng lệnh MOVE c ủa DOS.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  32  7) Tìm hi ểu hệ thống file NTFS. S ử dụng các ch ức năng c ủa NTFS trong h ệ điều 
hành Windows.  
8) Tìm hi ểu các h ệ thống file EXT c ủa LINUX.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  33  CHƢƠNG 5. TI ẾN TRÌNH VÀ DÒNG  
5.1. TIẾN TRÌNH (PROCESS)  
5.1.1.  Khái ni ệm 
Tiến trình là m ột chƣơng trình đang x ử lý. M ỗi tiến trình s ở hữu một con tr ỏ lệnh, 
tập các thanh ghi và các bi ến. Để hoàn thành tác v ụ của mình, m ột tiến trình có th ể 
cần đến một số tài nguyên nhƣ CPU, b ộ nhớ chính, các t ập tin và thi ết bị nhập xuất.  
5.1.2.  Mô hình ti ến trình  
Để hỗ trợ sự đa chƣơng, máy tính ph ải có kh ả năng th ực hiện nhi ều tác v ụ đồng 
thời. Nhƣng vi ệc điều khi ển nhi ều hoạt động song song ở cấp độ phần cứng là r ất khó 
khăn. Vì th ế các nhà thi ết kế hệ điều hành đ ề xuất một mô hình song song gi ả lặp bằng 
cách chuy ển đổi bộ xử lý qua l ại giữa các ti ến trình đ ể duy trì ho ạt động của nhi ều tiến 
trình cùng lúc, đi ều này t ạo cảm giác có nhi ều hoạt động đƣ ợc thực hiện đồng th ời.  
Về mặt ý ni ệm, có th ể xem nhƣ m ỗi tiến trình s ở hữu một bộ xử lý ảo của riêng 
nó. Nhƣng trong th ực tế, chỉ có m ột bộ xử lý thật sự đƣợc chuy ển đổi qua l ại giữa các 
tiến trình. S ự chuy ển đổi nhanh chóng này g ọi là sự đa chƣơng (multiprogramming). 
Hệ điều hành ch ịu trách nhi ệm sử dụng m ột thu ật toán đi ều phối để quyết định th ời 
điểm cần dừng ho ạt động của tiến trình đang x ử lý để phục vụ một tiến trình khác và 
lựa chọn tiến trình ti ếp theo s ẽ đƣợc phục vụ. Bộ phận thực hiện chức năng này c ủa hệ 
điều hành đƣ ợc gọi là b ộ điều phối (scheduler).  
5.1.3.   Các tr ạng thái c ủa tiến trình  
Trạng thái c ủa một tiến trình t ại một thời điểm đƣ ợc xác đ ịnh bởi hoạt động hi ện 
thời của tiến trình t ại thời điểm đó. T ại một thời điểm, m ột tiến trình có th ể nhận một 
trong các tr ạng thái sau đây:  
 New: ti ến trình đang đƣ ợc tạo lập.  
 Running: các ch ị thị của tiến trình đang đƣ ợc thực thi.  
 Blocked/waiting: ti ến trình ch ờ đƣợc cấp phát tài nguyên, hay ch ờ một sự 
kiện xảy ra.  
 Ready: ti ến trình đ ang ch ờ đƣợc cấp phát CPU.  
 Terminated: ti ến trình đã hoàn t ất xử lý.  
Tại một thời điểm, ch ỉ có m ột tiến trình có th ể nhận trạng thái running trên m ột bộ 
xử lý bất kỳ. Trong khi đó nhi ều tiến trình có th ể ở trạng thái blocked hay ready.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  34   
 Hình 5.1. Sơ đ ồ chuy ển trạng thái c ủa tiến trình  
Các cung chuy ển tiếp trong sơ đ ồ trạng thái bi ểu diễn sáu s ự chuy ển trạng thái có 
thể xảy ra trong các đi ều kiện sau:  
 (1): ti ến trình m ới đƣợc tạo đƣa vào h ệ thống.  
 (2): b ộ điều phối cấp phát cho ti ến trình m ột kho ảng thời gian s ử dụng CPU.  
 (3): ti ến trình k ết thúc.  
 (4): ti ến trình yêu c ầu tài nguyên nhƣng chƣa đƣ ợc đáp ứng vì tài nguyên 
chƣa s ẵn sàng đ ể cấp phát t ại thời điểm đó; ho ặc tiến trình ph ải chờ một sự 
kiện hay m ột thao tác nh ập/xuất.  
 (5): b ộ điều phối chọn một tiến trình khác đ ể cho x ử lý.  
 (6): tài nguyên mà ti ến trình yêu c ầu trở nên s ẵn sàng đ ể cấp phát; hay s ự 
kiện hoặc thao tác nh ập/xuất tiến trình đang đ ợi hoàn t ất.  
5.1.4.   Chế độ xử lý của tiến trình  
Để đảm bảo hệ thống ho ạt động đúng đ ắn, hệ điều hành c ần đƣợc bảo vệ khỏi sự 
xâm ph ạm của các ti ến trình. B ản thân các ti ến trình và d ữ liệu cũng c ần đƣợc bảo vệ 
để tránh các ảnh hƣ ởng sai l ạc lẫn nhau. M ột cách ti ếp cận để giải quy ết vấn đề là 
phân bi ệt hai ch ế độ xử lý cho các ti ến trình: ch ế độ đặc quy ền và chế độ không đ ặc 
quyền nhờ vào s ự trợ giúp c ủa cơ ch ế phần cứng. T ập lệnh của CPU đƣ ợc phân chia 
thành các l ệnh đặc quy ền và l ệnh không đ ặc quy ền. Cơ ch ế phần cứng ch ỉ cho phép 
các l ệnh đặc quy ền đƣ ợc thực hiện trong ch ế độ đặc quy ền. Thông thƣ ờng ch ỉ có hệ 
điều hành ho ạt động trong ch ế độ đặc quy ền, các ti ến trình c ủa ngƣ ời dùng ho ạt động 
trong ch ế độ không đ ặc quy ền, không th ực hiện đƣợc các l ệnh có nguy cơ ảnh hƣ ởng 
đến hệ thống. Nhƣ v ậy hệ điều hành s ẽ đƣợc bảo vệ. Khi m ột tiến trình ngƣ ời dùng 
gọi đến một lời gọi hệ thống, ti ến trình c ủa hệ điều hành x ử lý lời gọi này s ẽ hoạt động 
trong ch ế độ đặc quy ền, sau khi hoàn t ất thì tr ả quyền điều khi ển về cho ti ến trình 
ngƣời dùng trong ch ế độ không đ ặc quy ền.  
  
  
New 
  
Ready 
  
Run 
ning 
  
Terminated  
  
Blocked  
  
admitted  
  
interrupt  
  
exit 
  
Scheduler  
dispatch  
  
I/O or event  
completion  
  
I/O or event  
wait 
  
1 
  
2 
  
3 
  
4 
  
5 
  
6
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  35   
5.1.5.  Cấu trúc d ữ liệu kh ối quản lý ti ến trình  
Hệ điều hành qu ản lý các ti ến trình trong h ệ thống thông qua kh ối quản lý ti ến trình 
(Process Control Block – PCB). PCB là m ột vùng nh ớ lƣu tr ữ các thông tin mô t ả cho 
tiến trình v ới các thành ph ần chủ yếu bao g ồm:  
Định danh c ủa tiến trình  
Giúp phân bi ệt các tiến trình trong h ệ thống với nhau.  
Trạng thái ti ến trình  
Xác đ ịnh ho ạt động hi ện hành c ủa tiến trình.  
Ngữ cảnh của tiến trình  
Mô t ả các tài nguyên dành cho ti ến trình, ho ặc để phục vụ cho ho ạt động hi ện tại, 
hoặc để làm cơ s ở phục hồi hoạt động cho t iến trình, bao g ồm các thông tin v ề:  
 Trạng thái CPU: bao g ồm nội dung các thanh ghi, quan tr ọng nh ất là con 
trỏ lệnh IP lƣu tr ữ địa chỉ câu l ệnh kế tiếp tiến trình s ẽ xử lý. Các thông tin 
này c ần đƣợc lƣu tr ữ khi x ảy ra m ột ngắt, nhằm có th ể phục hồi hoạt động 
của tiến trình đúng nhƣ trƣ ớc lúc b ị ngắt.  
 Bộ xử lý: dùng cho máy có c ấu hình nhi ều CPU, xác đ ịnh số hiệu CPU mà 
tiến trình đang s ử dụng.  
 Bộ nhớ chính: danh sách các kh ối nhớ đƣợc cấp phát cho ti ến trình.  
 Tài nguyên s ử dụng: danh sách các tài nguy ên hệ thống mà ti ến trình đang 
sử dụng.  
 Tài nguyên t ạo lập: danh sách các tài nguyên đƣ ợc tiến trình t ạo lập.  
Thông tin giao ti ếp  
Phản ánh các thông tin v ề quan h ệ của tiến trình v ới các ti ến trình khác trong h ệ 
thống, bao g ồm:  
 Tiến trình cha: ti ến trình tạo lập tiến trình này.  
 Tiến trình con: các ti ến trình do ti ến trình này t ạo lập.  
 Độ ƣu tiên: giúp cho b ộ điều phối có thông tin đ ể lựa chọn tiến trình đƣ ợc 
cấp phát CPU.  
  
Hình 5.2.  
Hai ch ế độ xử lý của tiến trình  
  
User  
  
Shell, editors,…  
  
OS 
  
Hardware  
  
Chế độ không  
  
đặc quy ền 
  
Chế độ đặc quy ền
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  36  Thông tin th ống kê  
Đây là nh ững thông tin th ống kê v ề hoạt động của tiến trình  nhƣ th ời gian đã s ử 
dụng CPU, th ời gian ch ờ. Các thông tin này có th ể có ích cho vi ệc đánh giá tình hình 
hệ thống và d ự đoán các tình hu ống tƣơng lai.  
5.1.6. Thao tác trên ti ến trình  
Hệ điều hành cung c ấp các thao tác ch ủ yếu sau đây trên m ột tiến trình :  
 Tạo lập tiến tiến trình (create)  
 Kết thúc ti ến trình (destroy)  
 Tạm dừng tiến trình (suspend)  
 Tái kích ho ạt tiến trình (resume)  
 Thay đ ổi độ ƣu tiên ti ến trình  
5.1.7. Chuy ển đổi ngữ cảnh (Context switch)  
Chuy ển đổi CPU t ừ tiến trình này sang ti ến trình khác yêu c ầu hệ điều hành ph ải 
thực hiện lƣu tr ữ trạng thái c ủa tiến trình đang th ực hiện và ph ục hồi trạng thái c ủa 
tiến trình c ần chuy ển đến. Quá trình này g ọi là chuy ển đổi ngữ cảnh.  
Thời gian chuy ển đổi ngữ cảnh m ặc dù thƣ ờng rất ngắn (vài ms), nh ƣng đây là 
khoảng th ời gian lãng phí vì CPU không làm vi ệc có ích.  
  
Hình 5.3. Quá trình chuy ển đổi ngữ cảnh
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  37  5.1.8.  Cấp phát tài nguyên cho ti ến trình  
Khi có nhi ều ngƣ ời sử dụng đồng th ời làm vi ệc trong h ệ thống, h ệ điều hành ph ải 
cấp phát các tài nguyên theo  yêu c ầu cho m ỗi ngƣ ời sử dụng. Do tài nguyên h ệ thống 
thƣờng rất giới hạn và có khi không th ể chia s ẻ nên hi ếm khi t ất cả các yêu c ầu tài 
nguyên đ ồng th ời đều đƣ ợc thỏa mãn. Vì th ế cần phải nghiên c ứu một phƣơng pháp 
để chia s ẻ một số tài nguyên h ữu hạn giữa nhi ều tiến trình ngƣ ời dùng đ ồng th ời.  
Hệ điều hành qu ản lý nhi ều loại tài nguyên khác nhau (CPU, b ộ nhớ chính, các 
thiết bị ngoại vi,…), v ới mỗi loại cần có m ột cơ ch ế cấp phát và các chi ến lƣợc cấp 
phát hi ệu quả. Mỗi tài nguyên đƣ ợc biểu diễn thông qua m ột cấu trúc d ữ liệu khác 
nhau v ề chi ti ết cho t ừng lo ại tài nguyên, nhƣng cơ b ản chứa đựng các thông tin sau:  
 Định danh tài nguyên  
 Trạng thái tài nguyên: đây là các thông tin mô t ả chi ti ết trạng thái tài 
nguyên: ph ần nào c ủa tài nguyên đã c ấp phát cho ti ến trình, ph ần nào còn 
có th ể sử dụng?  
 Hàng đ ợi trên m ột tài nguyên: danh sách các ti ến trình đang ch ờ đƣợc cấp 
phát tài nguyên tƣơng ứng.  
 Bộ cấp phát: là đo ạn code đ ảm nhi ệm vi ệc cấp phát m ột tài nguyên đ ặc 
thù. M ột số tài nguyên đòi h ỏi các gi ải thuật đặc biệt (CPU, b ộ nhớ chính, 
hệ thống tập tin), trong khi nh ững tài nguyên khác (các thi ết bị nhập 
xuất,…) có th ể cần các gi ải thuật cấp phát và gi ải phóng t ổng quát hơn.  
Các m ục tiêu c ủa giải thuật cấp phát:  
 Bảo đảm một số lƣợng hợp lệ các ti ến trình truy xu ất đồng th ời đến các tài 
nguyên không chia s ẻ đƣợc.  
 Cấp phát tài nguyên cho ti ến trình có yêu c ầu trong m ột kho ảng th ời gian 
trì hoãn có th ể chấp nhận đƣợc.  
 Tối ƣu hóa s ự sử dụng tài nguyên.  
Để thỏa mãn các m ục tiêu k ể trên, c ần phải giải quy ết các v ấn đề nảy sinh khi có 
nhiều tiến trình đ ồng th ời yêu c ầu một tài nguyên không th ể chia s ẻ.  
5.2. TI ỂU TRÌNH (THREAD)  
Trong h ầu hết các h ệ điều hành, m ỗi tiến trình có m ột không gian đ ịa chỉ và ch ỉ 
có m ột dòng x ử lý. Tuy nhiên, có nhi ều tình hu ống ngƣời sử dụng mong mu ốn có 
nhiều dòng x ử lý cùng chia s ẻ một không gian đ ịa chỉ và các dòng x ử lý này ho ạt động 
song song tƣơng t ự nhƣ các ti ến trình phân bi ệt (ngo ại trừ việc chia s ẻ không gian đ ịa 
chỉ). Ngƣ ời ta c ần có m ột cơ ch ế xử lý mới cho phép có nh iều dòng x ử lý trong cùng 
một tiến trình. Ngày nay đã có nhi ều hệ điều hành cung c ấp cơ ch ế nhƣ th ế và gọi là 
tiểu trình (thread).
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  38  5.2.1.  Mô hình ti ểu trình (Thread Model)  
Một tiểu trình là m ột đơn v ị xử lý cơ b ản trong h ệ thống. M ỗi thread x ử lý tuần tự 
đoạn code c ủa nó, s ở hữu một con tr ỏ lệnh, tập các thanh ghi và m ột vùng nh ớ stack 
riêng. Các thread chia s ẻ  
CPU v ới nhau gi ống nhƣ cách chia s ẻ giữa các ti ến trình: m ột thread ch ờ xử lý 
trong khi các thread khác ch ờ đến lƣợt. Một thread cũng có th ể tạo lập các  thread con 
và nh ận các tr ạng thái khác nhau nhƣ m ột tiến trình th ật sự. Một tiến trình có th ể sở 
hữu nhi ều thread.  
Các ti ến trình t ạo thành nh ững th ực thể độc lập. M ỗi tiến trình có m ột tập tài 
nguyên và m ột môi trƣ ờng riêng (m ột con tr ỏ lệnh, m ột stack,  các thanh ghi và không 
gian đ ịa chỉ). Các ti ến trình hoàn toàn đ ộc lập với nhau, ch ỉ có th ể liên l ạc thông qua 
các cơ ch ế thông tin gi ữa các ti ến trình mà h ệ điều hành cung c ấp. Ngƣ ợc lại, các 
thread trong cùng m ột tiến trình l ại chia s ẻ một không gian đ ịa chỉ chung, đi ều này có 
nghĩa là các thread chia s ẻ các bi ến toàn c ục của tiến trình. M ột thread có th ể truy xu ất 
đến cả các stack c ủa những thread khác trong cùng m ột tiến trình. C ấu trúc này không 
đề nghị một cơ ch ế bảo vệ nào, và đi ều này cũng không th ật sự cần thiết vì các thread 
trong cùng m ột tiến trình thu ộc về cùng m ột sở hữu chủ đã tạo ra chúng trong ý đ ịnh 
cho phép chúng h ợp tác v ới nhau.  
 
Hình 5.4. Mô hình ti ến trình đơn lu ồng và đa lu ồng
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  39   
Hình 5 .5.   a) 3 ti ến trình v ới 1 thread       b) 1 tiến trình v ới 3 thread  
Thông tin chia s ẻ giữa các thread trong 
cùng ti ến trình  Các thông tin riêng c ủa thread  
Không gian đ ịa chỉ  Bộ đếm chƣơng trình  
Các bi ến toàn c ục  Các thanh ghi  
Các t ập tin m ở  Ngăn x ếp  
Các ti ến trình con  Trạng thái  
Các cảnh báo    
Các tín hi ệu và các b ộ xử lý tín hi ệu    
Thông tin tài kho ản    
5.2.2.  Ví dụ 
 Một chƣơng trình x ử lý văn b ản (word processor) có th ể chia thành 3 thread: 
một thread giao ti ếp với ngƣ ời dùng, m ột thread th ực hiện định dạng văn b ản 
và m ột thread th ực hiện truy xu ất đĩa. Gi ả sử ngƣời dùng x ử lý một văn b ản dài 
khoảng 800 trang, khi th ực hiện thao tác xóa ho ặc chỉnh sửa văn b ản chƣơng 
trình c ần phải thực hiện định dạng lại toàn b ộ văn b ản (thời gian r ất dài), khi đó 
thread đ ịnh dạng sẽ đƣợc thực hiện nền song song v ới thread giao ti ếp, ngƣ ời 
dùng s ẽ không ph ải chờ đợi trong lúc đ ịnh d ạng. Ngoài ra, vi ệc lƣu tr ữ dự 
phòng (backup) s ẽ đƣợc thực hiện ngầm với thread truy xu ất đĩa trong lúc v ẫn 
giao ti ếp với ngƣ ời dùng. Các tính năng trên không th ể thực hiện với nhi ều 
process đ ộc lập vì chúng c ần phải chia s ẻ vùng nh ớ chung (vùng văn b ản).
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  40    
Hình 5.6. Chƣơng trình x ử lý văn b ản với 3 thread  
 
Một tiến trình d ịch vụ (file, web, ftp, …) trên máy ch ủ (server) có th ể sử dụng mô 
hình đa lu ồng để đáp ứng yêu c ầu từ các máy con. Ti ến trình s ẽ hoạt động với một 
luồng nghe (Listener) chuyên nh ận lời yêu c ầu từ client, khi yêu c ầu đƣợc chấp nhận, 
một luồng m ới sẽ đƣợc tạo ra đ ể phục vụ cho yêu c ầu đó.  
  
Hình 5.7. Mô hình đa lu ồng cho server  
5.3. ĐIỀU PH ỐI TIẾN TRÌNH (SCH EDULE)  
Trong môi trƣ ờng đa chƣơng, có th ể xảy ra tình hu ống nhi ều tiến trình đ ồng th ời 
sẵn sàng đ ể xử lý. Lúc này, h ệ điều hành c ần phải thực hiện lựa chọn tiến trình đƣ ợc 
xử lý tiếp theo. B ộ phận thực hiện công vi ệc này g ọi là b ộ điều phối (scheduler).  
5.3.1.  Giới thiệu  
Mục tiêu đi ều phối 
Mục tiêu chung:  
 Công b ằng (Fairness): các ti ến trình đƣ ợc chia s ẻ CPU m ột cách công 
bằng, không có ti ến trình ph ải chờ vô hạn để đƣợc cấp phát CPU.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  41   Tôn tr ọng chính sách (Policy enforcement): vi ệc điều phối phải tuân th ủ 
theo các chính sách đã đ ặt ra c ủa hệ thống.  
 Cân b ằng (Balance): cân b ằng ho ạt động của tất cả các b ộ phận trong h ệ 
thống.  
Trong h ệ thống theo lô (Batch system):  
 Thông lƣ ợng (Throughput): c ực đại hóa s ố công vi ệc đƣợc xử lý trong m ột 
đơn v ị thời gian.  
 Thời gian lƣu l ại trong h ệ thống (Turnaround time): c ực tiểu hóa th ời gian 
hoàn t ất một tác v ụ.  
 Tận dụng CPU (CPU utilization): h ệ thống ph ải tận dụng hi ệu quả CPU.  
Trong h ệ thống tƣơng tác (interactive system):  
 Thời gian đáp ứng (Response time): c ực tiểu hóa th ời gian đáp ứng của tác 
vụ.  
 Cân đ ối (Proportionality): cân đ ối thời gian đáp ứng của các tác v ụ theo 
yêu c ầu của ngƣ ời sử dụng. Các đ ặc tính c ủa tiến trình  
 Tiến trình hƣ ớng nh ập xu ất (I/O -bound process): th ực hiện các yêu c ầu 
I/O nhi ều hơn s ử dụng C PU. Thƣ ờng các ti ến trình d ạng này s ử dụng CPU 
trong nh ững kho ảng th ời gian r ất ngắn.  
 Tiến trình hƣ ớng xử lý (CPU -bound process): s ử dụng CPU nhi ều, ít th ực 
hiện các yêu c ầu nhập xuất.  
 Tiến trình tƣơng tác hay x ử lý theo lô: ngƣ ời sử dụng theo ki ểu tƣơng  tác 
thƣờng yêu c ầu đƣ ợc hồi đáp t ức thời đối với các yêu c ầu của họ, trong 
khi các ti ến trình c ủa tác v ụ xử lý theo lô nói chung có th ể trì hoãn trong 
một thời gian ch ấp nhận đƣợc.  
 Độ ƣu tiên c ủa tiến trình: các ti ến trình có th ể đƣợc phân c ấp ƣu tiên th eo 
một số tiêu chu ẩn nào đó. Các ti ến trình có đ ộ ƣu tiên cao c ần đƣợc thực 
hiện trƣ ớc.  
 Thời gian đã s ử dụng CPU c ủa tiến trình: m ột số quan đi ểm ƣu tiên ch ọn 
những tiến trình đã s ử dụng CPU nhi ều thời gian nh ất vì hy v ọng chúng s ẽ 
cần ít th ời gian nh ất để hoàn t ất và r ời khỏi hệ thống. Tuy nhiên cũng có 
quan đi ểm cho r ằng các ti ến trình nh ận đƣ ợc CPU trong ít th ời gian là 
những tiến trình đã ph ải chờ lâu nh ất, do v ậy ƣu tiên ch ọn chúng.  
Thời gian còn l ại để tiến trình hoàn t ất: có th ể giảm thi ểu thời gian chờ đợi 
trung bình c ủa các ti ến trình b ằng cách cho các ti ến trình c ần ít th ời gian 
nhất để hoàn t ất đƣợc thực hiện trƣ ớc. Tuy nhiên th ực tế rất hiếm khi bi ết 
đƣợc tiến trình c ần bao nhiêu th ời gian n ữa để kết thúc x ử lý.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  42  Điều phối ưu tiên (preemptive) và không ưu tiên (non -preemptive)  
Hệ thống máy tính thƣ ờng có m ột đồng h ồ ngắt giờ (Interval timer / Interrupt 
clock), sau nh ững kho ảng th ời gian t sẽ phát sinh m ột ngắt (interrupt), lúc đó quy ền 
điều khi ển đƣợc trả về cho chƣơng trình x ử lý ng ắt của hệ điều hành. Tùy theo cách 
xử lý của hệ điều hành v ới ngắt giờ, ta có 2 ki ểu điều phối:  
 Non-preemptive: khi CPU đƣ ợc bộ điều phối cấp cho ti ến trình, nó s ẽ đƣợc 
quyền sử dụng đến khi k ết thúc ho ặc khi nó chuy ển sang tr ạng thái Blocked. 
Việc điều phối không đ ƣợc thực hiện khi ng ắt đồng hồ đƣợc kích ho ạt. 
 Preemptive: khi b ộ điều phối cấp CPU cho ti ến trình nó s ẽ quy đ ịnh th ời 
gian s ử dụng CPU c ủa tiến trình. Khi ng ắt đồng hồ đƣợc kích ho ạt, bộ điều 
phối sẽ kiểm tra th ời gian s ử dụng CPU c ủa tiến trình, n ếu hết thời gian mà 
tiến trình chƣa gi ải phóng CPU (k ết thúc ho ặc chuy ển sang tr ạng thái 
Blocked) thì ti ến trình s ẽ đƣợc chuy ển sang tr ạng thái Ready, nhƣ ờng CPU 
cho ti ến trình khác.  
5.3.2.  Các chiến lƣợc điều ph ối  
a) Chi ến lược FIFO (First In First Out)  
Nguyên t ắc: CPU c ấp phát cho ti ến trình đ ầu tiên trong danh sách s ẵn sàng có 
yêu c ầu, là ti ến trình đƣ ợc đƣa vào h ệ thống sớm nh ất. Đây là thu ật toán đi ều phối 
theo nguyên t ắc độc quy ền. M ột khi CPU đƣ ợc cấp phát cho ti ến trình, CPU ch ỉ đƣợc 
tiến trình t ự nguy ện giải phóng khi k ết thúc x ử lý hay khi có m ột yêu c ầu I/O.  
 
Hình 5 .8. Chi ến lƣợc FIFO  
Ví dụ: 
Xét t ập các ti ến trình sau:  
  
Tiến trình  Thời điểm vào  Thời gian x ử lý  
P1  0  12  
P2  1  3  
P3  3  1  
P4  6  4  
P5  10  2  
  
  
  
  
C 
  
B 
  
A 
  
CPU 
  
Kết thúc  
  
I/O 
  
Ready List
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  43  Thứ tự cấp phát CPU cho ti ến trình  là:  
  
Thời gian ch ờ đợi đƣợc xử lý của từng tiến trình:  
   P1 = 0  
  P2 = 12 - 1 = 11  
  P3 = 15 - 3 = 12  
  P4 = 16 - 6 = 10  
  P5 = 20 - 10 = 10  
-> Thời gian ch ờ đợi trung bình c ủa các ti ến trình:  (0 + 11 + 12 + 10 + 10)/5 = 8.6  
Ƣu & khuy ết điểm:  
 Đơn gi ản, dễ triển khai.  
 Không phù h ợp với hệ thống tƣơng tác do CPU không đƣ ợc cấp phát đ ều 
đặn cho các ti ến trình.  
 Xảy ra hi ện tƣợng tích lũy th ời gian ch ờ, các ti ến trình ng ắn phải đợi tiến 
trình có yêu c ầu CPU th ời gian dài k ết thúc x ử lý.  
b) Chi ến lược Round Robin  
Nguyên t ắc: danh sách s ẵn sàng đƣ ợc xử lý nhƣ m ột danh sách vòng, b ộ điều phối 
lần lƣợt cấp phát cho t ừng tiến trình trong danh sách m ột kho ảng th ời gian s ử dụng 
CPU g ọi là quantum. Đây là m ột giải thuật điều phối preemptive: khi  một tiến trình 
sử dụng CPU đ ến hết thời gian quantum dành cho nó, h ệ điều hành thu h ồi CPU và 
cấp cho ti ến trình k ế tiếp trong danh sách. N ếu tiến trình b ị khóa hay k ết thúc trƣ ớc 
khi s ử dụng hết thời gian quantum, h ệ điều hành cũng l ập tức cấp phát CPU c ho 
tiến trình khác. Khi ti ến trình tiêu th ụ hết thời gian CPU dành cho nó mà chƣa hoàn 
tất, tiến trình đƣ ợc đƣa tr ở lại vào cu ối danh sách s ẵn sàng đ ể đợi đƣợc cấp CPU 
trong lƣ ợt kế tiếp.  
 
Hình 5.9. Chi ến lƣợc Round Robin  
Ví dụ: Xét t ập các ti ến trình sa u:  
Tiến trình  Thời điểm vào  Thời gian x ử lý  
P1  0  12  
P2  1  3  
  
  
  
  
C 
  
B 
  
A 
  
CPU 
  
Kết thúc  
  
Hết quantum  
  
Ready List
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  44  P3  3  1  
P4  6  4  
P5  10  2  
Nếu sử dụng quantum là 2, th ứ tự cấp phát CPU cho ti ến trình s ẽ là:  
  
Thời gian ch ờ đợi đƣợc xử lý của từng tiến trình:  
    P1 = 0 + (4 - 2) + (10 - 6) + (16 - 12) = 10  
    P2 = (2 - 1) + (7 - 4) = 4   
    P3 = 6 - 3 = 3  
    P4 = (8 - 6) + (14 - 10) = 6  
    P5 = 12 - 10 = 2  
Thời gian ch ờ đợi trung bình c ủa các ti ến trình:  (10 + 4 + 3 + 6 + 2)/5 = 5.0  
Nếu có n ti ến trình trong danh sách s ẵn sàng  và sử dụng quantum q, thì m ỗi tiến 
trình s ẽ không ph ải đợi quá (n -1)q đơn v ị thời gian trƣ ớc khi nh ận đƣ ợc CPU cho 
lƣợt kế tiếp.  
 
Ƣu & khuy ết điểm:   
 Phù h ợp với hệ thống chia s ẻ thời gian.  
 Khó trong vi ệc xác đ ịnh quantum h ợp lý: n ếu quantum quá dài thì  trở 
thành gi ải thu ật FIFO, n ếu quantum quá bé s ẽ phát sinh nhi ều thời gian 
chuy ển đổi ngữ cảnh gi ữa các ti ến trình làm cho vi ệc sử dụng CPU kém 
hiệu quả.  
c) Đi ều phối với độ ưu tiên (Priority)  
Nguyên t ắc: mỗi tiến trình đƣ ợc gán cho m ột độ ƣu tiên tƣơng  ứng, ti ến trình có 
độ ƣu tiên cao nh ất sẽ đƣợc chọn để cấp phát CPU đ ầu tiên. Đ ộ ƣu tiên có th ể đƣợc 
định nghĩa n ội tại hay nh ờ vào các y ếu tố bên ngoài.  
Giải thu ật điều ph ối với độ ƣu tiên có th ể theo nguyên t ắc preemptive hay  non -
preemptive. Khi m ột tiến trình đƣ ợc đƣa vào danh sách các ti ến trình s ẵn sàng, đ ộ ƣu 
tiên c ủa nó đƣ ợc so sánh v ới độ ƣu tiên c ủa tiến trình hi ện hành đang đƣ ợc xử lý. Gi ải 
thuật điều phối với độ ƣu tiên preemptive s ẽ thu h ồi CPU t ừ tiến trình hi ện hành đ ể 
cấp phát cho ti ến trình m ới nếu độ ƣu tiên c ủa tiến trình này cao hơn ti ến trình hi ện 
hành. Còn gi ải thu ật non -preemptive s ẽ chỉ chèn ti ến trình m ới vào danh sách s ẵn 
sàng và ti ến trình hi ện hành v ẫn tiếp tục xử lý hết thời gian dành cho nó.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  45  Ví dụ: Xét t ập các ti ến trình sau:  
  
Tiến trình  Thời điểm vào  Thời gian x ử lý  Độ ƣu tiên  
P1  0  12  3  
P2  1  3  2  
P3  3  1  1  
P4  6  4  4  
P5  10  2  0  
Qui ƣ ớc là giá tr ị biểu diễn càng nh ỏ thì độ ƣu tiên càng cao.  
Kết quả điều phối theo ch ế độ độc quy ền (non -preemptive)  
  
Thời gian ch ờ đợi đƣợc xử lý của từng tiến trình:  
   P1 = 0  
  P2 = 15 - 1 = 14  
  P3 = 14 - 3 = 11  
  P4 = 18 - 6 = 12  
  P5 = 12 - 10 = 2  
Thời gian ch ờ đợi trung bình c ủa các ti ến trình:  (0 + 14 + 11 + 12 + 2)/5 = 7.8  
 Kết quả điều phối theo ch ế độ không đ ộc quy ền (preemptive)  
  
Thời gian ch ờ đợi đƣợc xử lý của từng tiến trình:  
  P1 = 0 + (5 - 1) + (12 - 10) = 6  
  P2 = 0 + (4 - 3) = 1  
   P3 = 0  
  P4 = 18 - 6 = 12  
   P5 = 0  
Thời gian ch ờ đợi trung bình c ủa các ti ến trình:  (6 + 1 + 0 + 12 + 0)/5 = 3.8  
Thảo luận: tình tr ạng đói CPU (starvation) là m ột vấn đề chính y ếu của các 
giải thu ật sử dụng độ ƣu tiên. Các gi ải thu ật này có th ể để các ti ến trình có đ ộ ƣu
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  46  tiên th ấp chờ đợi CPU vô h ạn. Để ngăn c ản các ti ến trình có đ ộ ƣu tiên cao chi ếm 
dụng CPU vô th ời hạn, bộ điều phối sẽ giảm dần độ ƣu tiên c ủa các ti ến trình này 
sau m ỗi ngắt đồng hồ. Nếu độ ƣu tiên c ủa tiến trình này gi ảm xu ống th ấp hơn ti ến 
trình có đ ộ ƣu tiên cao th ứ nhì, s ẽ xảy sự chuy ển đổi quy ền sử dụng CPU. Quá trình 
này g ọi là sự lão hóa (aging) ti ến trình.  
d) Chi ến lược SJF (Shortest Job First)  
Nguyên t ắc: đây là m ột trƣờng hợp đặt biệt của điều phối với độ ƣu tiên. Trong 
giải thuật này, đ ộ ƣu tiên p đƣ ợc gán cho m ỗi tiến trình là ngh ịch đảo của thời gian 
xử lý t mà ti ến trình yêu c ầu. CPU s ẽ đƣợc cấp phát cho ti ến trình yêu c ầu ít th ời 
gian nh ất. Gi ải thu ật này cũng có th ể theo nguyên t ắc preemptive hay non -
preemptive. S ự chọn lựa xảy ra khi có m ột tiến trình m ới đƣợc đƣa vào danh sách 
sẵn sàng trong khi m ột tiến trình khác đang x ử lý. N ếu thời gian x ử lý của tiến trình 
mới ngắn hơn th ời gian yêu c ầu xử lý còn l ại của tiến trình hi ện hành, gi ải thuật SJF 
preemptive s ẽ dừng ho ạt động của tiến trình hi ện hành, trong khi gi ải thu ật non -
preemptive s ẽ cho phép ti ến trình hi ện hành  tiếp tục xử lý.  
Thảo luận: giải thuật này cho phép đ ạt đƣợc thời gian ch ờ trung bình c ực tiểu. 
Khó khăn l ớn nhất của giải thuật là xác đ ịnh th ời gian yêu c ầu xử lý còn l ại của tiến 
trình. Thƣ ờng ph ải thực hiện dự đoán thông qua các kho ảng th ời gian đã s ử dụng 
CPU trƣ ớc kia c ủa tiến trình.  
Ví dụ: Xét t ập các ti ến trình sau:  
  
Tiến trình  Thời điểm vào  Thời gian x ử lý  
P1  0  12  
P2  1  3  
P3  3  1  
P4  6  4  
P5  10  2  
 Kết quả điều phối theo ch ế độ độc quy ền (non -preemptive)  
  
Thời gian ch ờ đợi đƣợc xử lý của từng tiến trình:  
    P1 = 0  
   P2 = 15 - 1 = 14    P3 = 12 - 3 = 
9  
    P4 = 18 - 6 = 12
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  47      P5 = 13 - 10 = 3  
Thời gian ch ờ đợi trung bình c ủa các ti ến trình:  (0 + 14 + 9 + 12 + 3)/5 = 7.6  
Kết quả điều phối theo ch ế độ không đ ộc quy ền (preemptive)  
  
Thời gian ch ờ đợi đƣợc xử lý của từng tiến trình:  
    P1 = 0 + (5 - 1) + (12 - 6) = 10  
    P2 = 0  
    P3 = 4 - 3 = 1  
    P4 = 0  
    P5 = 0  
Thời gian ch ờ đợi trung bình c ủa các ti ến trình:  (10 + 0 + 1 + 0 + 0)/5 = 
2.2  
e) Chi ến lược điều phối với nhiều mức độ ưu tiên  
Nguyên t ắc: ý tƣởng chính c ủa giải thuật là phân l ớp các ti ến trình tùy theo đ ộ ƣu tiên 
của chúng đ ể có cách th ức điều phối thích h ợp theo t ừng nhóm. Danh sách s ẵn sàng 
đƣợc phân tách thành các danh sách riêng bi ệt theo  cấp độ ƣu tiên, m ỗi danh sách bao 
gồm các ti ến trình có cùng đ ộ ƣu tiên và đƣ ợc áp d ụng m ột giải thu ật thích h ợp để 
điều phối. Ngoài ra, còn có m ột giải thuật điều phối giữa các nhóm, thƣ ờng gi ải thuật 
này là gi ải thu ật preemptive và s ử dụng độ ƣu tiên c ố định. CPU s ẽ luân phiên ph ục 
vụ các danh sách theo đ ộ ƣu tiên c ủa chúng.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  48    
Hình 5.10. Mô hình đi ều ph ối nhi ều cấp độ ƣu tiên  
Thảo luận: có th ể xảy ra tình tr ạng đói CPU c ủa các ti ến trình ở danh sách có đ ộ 
ƣu tiên th ấp. Do v ậy có th ể xây d ựng gi ải thu ật điều phối nhi ều cấp ƣu tiên và xoay 
vòng. Gi ải thu ật này s ẽ chuy ển dần một tiến trình t ừ danh sách có đ ộ ƣu tiên cao 
xuống danh sách có đ ộ ƣu tiên th ấp hơn sau m ỗi lần sử dụng CPU. Tƣơng t ự, một tiến 
trình ch ờ quá lâu trong các danh sách có đ ộ ƣu tiên th ấp cũng có th ể đƣợc chuy ển dần 
lên các danh sách có đ ộ ƣu tiên cao hơn. Khi xây d ựng m ột giải thuật điều phối nhiều 
cấp ƣu tiên và xoay vòng c ần quy ết định các tham s ố:  
 Số lƣợng các c ấp ƣu tiên.  
 Giải thuật điều phối cho t ừng danh sách ứng với một cấp ƣu tiên.  
 Phƣơng pháp xác đ ịnh th ời điểm di chuy ển một tiến trình lên danh sách có 
độ ƣu tiên cao hơn.  
 Phƣơng pháp xác đ ịnh th ời điểm di chuy ển một tiến trình lên danh sách có 
độ ƣu tiên th ấp hơn.  
 Phƣơng pháp s ử dụng đ ể xác đinh m ột tiến trình m ới đƣợc đƣa vào h ệ 
thống sẽ thuộc danh sách ứng với độ ƣu tiên nào.  
5.4. ĐỒNG B Ộ HÓA TI ẾN TRÌNH  
5.4.1.  Giới thiệu 
Nhu c ầu đồng bộ hóa
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  49  Trong m ột hệ thống cho phép các ti ến trình liên l ạc với nhau, bao gi ờ hệ điều 
hành cũng c ần cung c ấp kèm theo nh ững cơ ch ế đồng bộ hóa vì các lý  do sau 
đây:  
Yêu c ầu độc quy ền truy xu ất (Mutual exclusion)  
Các tài nguyên trong h ệ thống đƣ ợc phân thành hai lo ại: tài nguyên có th ể chia 
sẻ cho phép nhi ều tiến trình đ ồng th ời truy xu ất và các tài nguyên không th ể 
chia s ẻ chỉ chấp nhận một (hay m ột số lƣợng hạn chế) tiến trình s ử dụng tại 
một thời điểm. Tính không chia s ẻ của tài nguyên thƣ ờng có ngu ồn gốc từ một 
trong hai nguyên nhân sau đây:  
 Đặc tính c ấu tạo phần cứng của tài nguyên không cho phép chia s ẻ.  
 Nếu nhi ều tiến trình s ử dụng tài nguyên đ ồng thời, có nguy cơ x ảy ra các 
kết quả không d ự đoán đƣ ợc do ho ạt động c ủa các ti ến trình trên tài 
nguyên ảnh hƣ ởng lẫn nhau.  
Để giải quy ết vấn đề, cần bảo đảm tiến trình đ ộc quy ền truy xu ất tài nguyên, 
nghĩa là h ệ thống ph ải kiểm soát sao cho t ại một thời điểm, ch ỉ có m ột tiến trình đƣ ợc 
quyền truy xu ất một tài nguyên không th ể chia s ẻ.  
Yêu c ầu phối hợp (Synchronization)  
Nhìn chung, m ối tƣơng quan v ề tốc độ thực hiện của hai ti ến trình trong h ệ thống 
là không th ể biết trƣớc, vì đi ều này ph ụ thuộc vào nhi ều yếu tố động nhƣ t ần suất xảy 
ra các ng ắt của từng tiến trình, th ời gian ti ến trình đƣ ợc cấp phát CPU, … Có th ể nói 
rằng các ti ến trình ho ạt động không đ ồng bộ với nhau. Nhƣng có nh ững tình hu ống 
các ti ến trình c ần hợp tác trong vi ệc hoàn thành tác v ụ, khi đó c ần phải đồng bộ hóa 
hoạt động của các ti ến trình. Ví d ụ: một tiến trình ch ỉ có th ể xử lý nếu một tiến trình 
khác đã k ết thúc m ột công vi ệc nào đó.  
Miền tranh ch ấp (Critical Section)  
Đoạn chƣơng trình trong đó có kh ả năng x ảy ra các mâu thu ẫn truy xuất trên tài 
nguyên chung đƣ ợc gọi là mi ền tranh ch ấp (Critical Section).  
Ví d ụ: giả sử có hai ti ến trình P1 và P2 th ực hiện công vi ệc của các k ế toán, và 
cùng chia s ẻ một vùng nh ớ chung lƣu tr ữ biến taikhoan  phản ánh thông tin v ề tài 
khoản. M ỗi tiến trình mu ốn rút m ột kho ản tiền tienrut  từ tài kho ản:  
 if (taikhoan – tienrut >=0)    taikhoan = taikhoan - 
tienrut ;  else  
    error(”Không th ể rút ti ền”);  
Giả sử trong tài kho ản hiện còn 800, P1 mu ốn rút 500 và P2 mu ốn rút 400. N ếu 
xảy ra tình hu ống nhƣ sa u:  
 Sau khi đã ki ểm tra đi ều kiện (taikhoan - tienrut>=0)  và nh ận kết quả là 
True, P1 h ết thời gian x ử lý mà h ệ thống cho phép, h ệ điều hành c ấp phát 
CPU cho P2.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  50   P2 ki ểm tra cùng đi ều kiện trên và cũng nh ận đƣợc kết quả là True (do P1 
vẫn chƣa rút ti ền) và rút 400. Giá tr ị của taikhoan  đƣợc cập nhật lại là 400.  
 Khi P1 đƣ ợc tái kích ho ạt và ti ếp tục xử lý, nó th ực hiện tiếp câu 
lệnh rút ti ền và c ập nhật lại taikhoan  là -100 -> Tình hu ống lỗi xảy ra.  
Các tình hu ống tƣơng t ự nhƣ th ế có th ể xảy ra khi có nhi ều tiến trình đ ọc và ghi 
dữ liệu trên vùng nh ớ chung, và k ết quả phụ thuộc vào s ự điều phối tiến trình c ủa 
hệ thống – đƣợc gọi là các tình hu ống tranh đo ạt điều khi ển (race condition).  
Trong ví d ụ, trên đo ạn mã: if (taikhoan – tienrut >=0)   taikhoan = ta ikhoan - 
tienrut ; của mỗi tiến trình t ạo thành m ột miền tranh ch ấp.  
Có th ể giải quy ết vấn đề mâu thu ẫn truy xu ất nếu có th ể bảo đảm tại một thời 
điểm ch ỉ có duy nh ất một tiến trình đƣ ợc xử lý lệnh trong mi ền tranh ch ấp.  
Một phƣơng pháp gi ải quy ết tốt bài toán mi ền tranh ch ấp cần thỏa mãn 4 đi ều 
kiện sau:  
 Không có hai ti ến trình cùng ở trong mi ền tranh ch ấp cùng m ột lúc.  
 Không có gi ả thiết nào đ ặt ra cho s ự liên h ệ về tốc độ của các ti ến trình, 
cũng nhƣ v ề số lƣợng bộ xử lý trong h ệ thống.  
 Một tiến trình tạm dừng bên ngoài mi ền tranh ch ấp không đƣ ợc ngăn c ản 
các ti ến trình khác vào mi ền tranh ch ấp.  
 Không có ti ến trình nào ph ải chờ vô hạn để đƣợc vào mi ền tranh ch ấp.  
5.4.2.  Các gi ải pháp  
Sử dụng bi ến cờ hiệu  
Các ti ến trình chia s ẻ một biến chung đóng vai tr ò “ch ốt cửa” (lock), bi ến này 
đƣợc khởi động là 0. M ột tiến trình mu ốn vào mi ền tranh ch ấp trƣ ớc tiên ph ải 
kiểm tra giá tr ị của biến lock. N ếu lock=0, ti ến trình đ ặt lại giá tr ị cho lock=1 
và đi vào mi ền tranh ch ấp. Nếu lock đang nh ận giá tr ị 1, tiến trình  phải chờ bên 
ngoài mi ền tranh ch ấp cho đ ến khi lock có giá tr ị 0. Nhƣ v ậy giá tr ị 0 của lock 
mang ý nghĩa là không có ti ến trình nào đang ở trong mi ền tranh ch ấp, và 
lock=1 khi có m ột tiến trình đang ở trong mi ền tranh ch ấp.  
Cấu trúc m ột chƣơng trình s ử dụng bi ến khóa đ ể đồng bộ:  
 while (TRUE)  
{  
     while (lock==1) ; //wait   
   lock=1;  
        critical -section();  
     lock=0;
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  51       noncritical -
section();    }  
Giải pháp này có th ể vi ph ạm điều kiện thứ nhất: hai ti ến trình có th ể cùng ở trong 
miền tranh ch ấp tại một thời điểm. Gi ả sử một tiến trình nh ận thấy lock=0 và 
chuẩn bị vào mi ền tranh ch ấp, nhƣng trƣ ớc khi nó có th ể đặt lại giá tr ị cho lock là 
1, nó b ị tạm dừng để một tiến trình  
khác ho ạt động. Ti ến trình th ứ hai này th ấy lock v ẫn là 0 thì v ào mi ền tranh ch ấp 
và đặt lại lock=1. Sau đó ti ến trình th ứ nhất đƣợc tái kích ho ạt, nó gán lock=1 l ần 
nữa rồi vào mi ền tranh ch ấp. Nhƣ v ậy tại thời điểm đó c ả hai ti ến trình đ ều ở 
trong mi ền tranh ch ấp.  
Sử dụng ki ểm tra luân phiên  
Đây là m ột giải pháp đ ề nghị cho hai ti ến trình. Hai ti ến trình này s ử dụng 
chung bi ến turn (ph ản ánh ti ến trình nào đƣ ợc vào mi ền tranh ch ấp) đƣ ợc khởi 
động v ới giá tr ị 0. Nếu turn=0, ti ến trình A đƣ ợc vào mi ền tranh ch ấp. Nếu 
turn=1, ti ến trình A đi vào m ột vòng l ặp chờ đến khi turn nh ận giá tr ị 0. Khi 
tiến trình A r ời khỏi miền tranh ch ấp, nó đ ặt giá tr ị turn v ề 1 để cho phép ti ến 
trình B đi vào mi ền tranh ch ấp.  
Cấu trúc ti ến trình A:  
 while (TRUE)  
{  
     while (turn !=0) ; //wait  
        critical -section();  
     turn=1 ;  
     noncritical -
section();    }  
Cấu trúc ti ến trình B:  
 while (TRUE)  
{  
     while (turn !=1) ; //wait  
        critical -section();  
     turn=0;  
     noncritical -
section();    }  
Giải pháp này d ựa trên vi ệc thực hiện sự kiểm tra nghiêm ng ặt đên lƣ ợt tiến trình 
nào đƣ ợc vào mi ền tranh ch ấp. Do đó có th ể ngăn ch ặn tình tr ạng cả hai ti ến trình 
cùng vào m ột lúc. Nhƣng l ại có th ể vi ph ạm điều kiện thứ ba: m ột tiến trình có th ể bị
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  52  ngăn ch ặn vào mi ền tranh ch ấp bởi một tiến trình khác không ở trong mi ền tranh ch ấp. 
Giả sử tiến trình B ra kh ỏi miền tranh ch ấp rất nhanh chóng. C ả hai ti ến trình đ ều ở 
ngoài mi ền tranh ch ấp và turn=0. Ti ến trình A vào mi ền tranh ch ấp và ra kh ỏi nhanh 
chóng, đ ặt lại giá tr ị của turn là 1, r ồi lại xử lý đo ạn lệnh ngoài mi ền tran h chấp lần 
nữa. Sau đó, ti ến trình A l ại kết thúc nhanh chóng đo ạn lệnh ngoài mi ền tranh ch ấp 
của nó và mu ốn vào l ại một lần nữa. Tuy nhiên, lúc này B v ẫn còn mãi x ử lý đo ạn 
lệnh ngoài mi ền tranh ch ấp của mình, và turn l ại mang giá tr ị 1. Nhƣ v ậy, giải phá p 
này không có giá tr ị khi có s ự khác bi ệt lớn về tốc độ thực hiện của hai ti ến trình, nó 
vi ph ạm cả điều kiện thứ hai.  
Giải pháp c ủa Peterson Peterson đƣa ra m ột giả pháp k ết hợp ý tƣ ởng của cả hai 
giải pháp trên. Các ti ến trình chia s ẻ hai bi ến chung:  
 int turn; //đ ến phiên ai  
int interesse[2]; //kh ởi động là FALSE  
 
Nếu interesse[i]=TRUE có nghĩa là ti ến trình Pi mu ốn vào mi ền tranh ch ấp. 
Khởi đầu, interesse[0]=interesse[1]=FALSE và giá tr ị của turn đƣ ợc khởi động 
là 0 hay 1. Đ ể có th ể vào đƣ ợc miền tranh ch ấp, trƣ ớc tiên ti ến trình Pi đ ặt giá tr ị 
interesse[i]=TRUE (xác đ ịnh rằng tiến trình mu ốn vào mi ền tranh ch ấp), sau đó 
đặt turn=j (đ ề nghị thử tiến trình khác vào mi ền tranh ch ấp). N ếu tiến trình Pj 
không quan tâm đ ến việc vào mi ền tranh ch ấp (inter esse[j]=FALSE), thì Pi có 
thể vào mi ền tranh ch ấp, nếu không, Pi ph ải chờ đến khi interesse[j]=FALSE. 
Khi ti ến trình Pi r ời kh ỏi mi ền tranh ch ấp, nó l ại đặt lại giá tr ị cho 
interesse[i]=FALSE.  
 Cấu trúc c ủa tiến trình Pi trong gi ải pháp Peterson:  
 while (TRUE)  
{  
      int j=1 -i; //j là ti ến trình còn l ại  
     interesse[i]=TRUE;      turn=j;   
   while (turn ==j && interesse[j]==TRUE) ; 
//wait  
        critical -section();  
     interesse[i]=FALSE;  
     noncritical -
section();    }  
Giải pháp này ngăn ch ặn đƣợc tình tr ạng mâu thu ẫn truy xu ất: mỗi tiến trình Pi 
chỉ có th ể vào mi ền tranh ch ấp khi interesse[j]=FALSE ho ặc turn=i. N ếu cả hai 
tiến trình đ ều mu ốn vào mi ền tranh ch ấp thì interesse[i]=interesse[j]=TRUE
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  53  nhƣng giá tr ị của turn ch ỉ có th ể hoặc là 0 h oặc là 1, do v ậy chỉ có m ột tiến trình 
đƣợc vào mi ền tranh ch ấp.  
Cấm ng ắt  
Phần cứng cho phép ti ến trình c ấm tất cả các ng ắt trƣớc khi vào mi ền tranh 
chấp và ph ục hồi ngắt khi ra kh ỏi miền tranh ch ấp. Khi đó, ng ắt đồng hồ cũng 
không x ảy ra, do v ậy hệ thống không th ể tạm dừng ho ạt động của tiến trình đang 
xử lý để cấp phát CPU cho ti ến trình khác, nh ờ đó ti ến trình hi ện hành yên tâm 
thao tác trên mi ền tranh ch ấp mà không s ợ bị tiến trình nào khác tranh ch ấp.  
Giải pháp này không đƣ ợc ƣa chu ộng vì r ất thiếu thận trọng khi cho phép ti ến 
trình ngƣ ời dùng đƣ ợc phép th ực hiện lệnh cấm ng ắt. Hơn n ữa, nếu hệ thống có 
nhiều bộ xử lý, lệnh cấm ng ắt chỉ có tác d ụng trên b ộ xử lý đang x ử lý tiến trình, 
còn các ti ến trình ho ạt động trên các b ộ xử lý khác v ẫn có th ể vào đƣợc mi ền 
tranh ch ấp.  
Chỉ thị TSL (Test -and-Set)  
Đây là m ột giải pháp đòi h ỏi sự trợ giúp c ủa cơ ch ế phần cứng. Nhi ều máy tính 
cung c ấp một chỉ thị đặc biệt cho phép ki ểm tra và c ập nhật nội dung m ột vùng 
nhớ trong m ột thao tác không th ể phân chia, g ọi là chỉ thị Test-and-Set Lock 
(TSL) và đƣ ợc định nghĩa nhƣ sau:  
 Test-and-Setlock (boolean target)  
    {  
      Test-and-Setlock = target;  
   Target = TRUE;  
    }  
Nếu có hai ch ỉ thị TSL x ử lý đồng th ời (trên hai b ộ xử lý khác nhau), chúng s ẽ 
đƣợc xử lý tuần tự. Có th ể cài đ ặt giải pháp truy xu ất độc quy ền với TSL b ằng 
cách s ử dụng thêm m ột biến lock, đƣ ợc khởi gán là FALSE. Ti ến trình ph ải kiểm 
tra giá tr ị của biến lock trƣ ớc khi vào mi ền tranh ch ấp, nếu lock=FALSE, ti ến 
trình có th ể vào mi ền tranh ch ấp.  
Cấu trúc m ột chƣơng trình trong gi ải pháp TSL:  
 while (TRUE)   
 {  
     while (Test -and-Setlock(lock));  
        critical -section();  
     lock = FALSE;  
     Noncritical -
section();    }
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  54  Cũng gi ống nhƣ các gi ải pháp ph ần cứng khác, ch ỉ thị TSL ch ỉ giảm nhẹ công 
việc lập trình đ ể giải quy ết vấn đề, nhƣng l ại không d ễ dàng đ ể cài đ ặt chỉ thị TSL 
sao cho đƣ ợc xử lý một cách không th ể phân chia, nh ất là trên máy v ới cấu hình 
nhiều bộ xử lý.  
->Tất cả các gi ải pháp trình bày ở trên đ ều phải thực hiện một vòn g lặp để 
kiểm tra li ệu tiến trình có đư ợc phép vào mi ền tranh ch ấp. Nếu điều kiện chưa 
cho phép, ti ến trình ph ải chờ tiếp tục trong vòng l ặp kiểm tra này. Các gi ải pháp 
buộc tiến trình ph ải liên t ục kiểm tra đi ều kiện để phát hi ện thời điểm thích h ợp để 
vào miền tranh ch ấp như th ế được gọi là các gi ải pháp “busy waiting”. Lưu ý 
rằng vi ệc kiểm tra như th ế tiêu th ụ rất nhiều thời gian s ử dụng CPU, do v ậy tiến 
trình đang ch ờ vẫn chi ếm dụng CPU. Xu hư ớng gi ải quy ết vấn đề đồng bộ hóa là 
nên tránh các gi ải pháp “busy waiting”.   
Semaphore  
Đƣợc Dijkstra đ ề xuất vào năm 1965, m ột semaphore s là m ột biến có các thu ộc 
tính sau:  
1. Một giá tr ị nguyên dƣơng e(s).  
2. Một hàng đ ợi f(s) lƣu danh sách các ti ến trình đang b ị khóa (ch ờ) trên 
semaphore s.  
3. Chỉ có hai thao tác đƣ ợc định nghĩa trên semaphore 
  Down(s) : 
giảm giá tr ị của semaphore s đi 1 đơn v ị. Nếu semaphore có tr ị 
e(s)>0 thì ti ếp tục xử lý. Ngƣ ợc lại, nếu e(s) ≤ 0, ti ến trình ph ải chờ 
cho đ ến khi e(s)>0.  
 Up(s) : tăng giá tr ị của semaphore s lên 1 đơn v ị. Nếu có m ột hoặc nhi ều 
tiến trình đang ch ờ trên semaphore s, b ị khóa b ởi thao tác Down, thì h ệ 
thống sẽ chọn một trong các ti ến trình này đ ể kết thúc thao tác Down và 
cho ti ếp tục xử lý.  
 
Cài đ ặt: gọi p là ti ến trình th ực hiện thao tác Down(s) hay Up(s).  
 Down(s)  
e(s) = e(s) – 1;  
      if e(s) <0  
        {   
Sema phore  
  
 e(s) 
  
 f 
) 
s 
( 
  
S1 
  
 - 
1 
  
   
S2 
  
 0 
  
 Null 
  
S3 
  
 - 
2 
  
   
P1 
  
P2 
  
P3
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  55           status(P) = 
blocked;         
 enter(P, f(s));  
        }  
 Up(s)  
e(s) = e(s) + 1;  
      if e(s) <= 0  
        {   
         exit(Q, f(s)); // Q là ti ến trình 
đang ch ờ trên s status(Q) = ready;  
          enter(Q, ready -list);  
        }  
Lƣu ý cài đ ặt này có th ể đƣa đ ến một giá tr ị âm cho semaphore, khi đó tr ị tuyệt 
đối của semaphore cho bi ết số tiến trình đang ch ờ trên semaphore. Đi ều quan tr ọng là 
các thao tác này c ần thực hiện một cách không b ị phân chia, không b ị ngắt nửa chừng, 
có nghĩa là không m ột tiến trình nào đƣ ợc phép truy xu ất đến semaphore n ếu tiến trình 
đang thao tác trên semaphore này chƣa k ết thúc x ử lý hay chuy ển sang tr ạng thái 
blocked.  
Sử dụng: có th ể dùng semaphore đ ể giải quy ết vấn đề truy xu ất độc quy ền hay t ổ 
chức phối hợp giữa các ti ến trình.  
 Tổ chức truy xu ất độc quy ền với semaphore: cho phép b ảo đảm nhi ều tiến 
trình cùng truy xu ất đến miền tranh ch ấp mà không có s ự mâu thu ẫn truy 
xuất. n ti ến trình cùng s ử dụng m ột semaphore  s, e(s) đƣ ợc khởi gán là 1. 
Để thực hiện đồng bộ hóa, t ất cả các ti ến trình c ần phải áp d ụng cùng c ấu 
trúc chƣơng trình sau đây:  
while (TRUE)  
        {  
         Down(s);  
              critical -section();  
           Up(s);  
            Noncritical -section();  
        }  
 Tổ chức đồng bộ hóa v ới semaphore: ta có th ể đồng bộ hóa ho ạt động của 
hai ti ến trình trong tình hu ống m ột tiến trình ph ải đợi một tiến trình khác 
hoàn t ất thao tác nào đó m ới có th ể bắt đầu hay ti ếp tục xử lý. Hai ti ến
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  56  trình chia s ẻ một semaphore s, kh ởi gán e(s) là 0. C ả hai ti ến trình có c ấu 
trúc nhƣ sau:  
 
P1 P2  
{  {   
  while (TRUE)   while (TRUE)  
 {  {   job1(); Down(s); //chờ  P1  
    
  job2();  
    }  }   
} }  
 
Thảo luận: nhờ có th ể thực hiện một cách không th ể phân chia, semaphore gi ải 
quyết đƣợc vấn đề tín hi ệu “đánh th ức” bị thất lạc. Tuy nhiên, n ếu lập trình viên vô 
tình đ ặt các primitive Down và Up sai v ị trí, th ứ tự trong chƣơng trình thì ti ến trình có 
thể bị khóa vĩnh vi ễn. Vì th ế, việc sử dụng đúng cách semaphore đ ể đồng bộ hóa ph ụ 
thuộc hoàn toàn vào l ập trình viên và đòi h ỏi lập trình viên ph ải hết sức thận trọng.  
5.5. TẮC NGH ẼN (DEADLOCK)  
5.5.1.  Định nghĩa  
Một tập hợp các ti ến trình đƣ ợc định nghĩa là ở trong tình tr ạng tắc ngh ẽn khi m ỗi tiến 
trình  trong t ập hợp đều chờ đợi một sự kiện mà ch ỉ có m ột tiến trình khác trong t ập 
hợp mới có th ể phát sinh đƣ ợc.  
Nói cách khác m ỗi tiến trình trong t ập hợp đều chờ đợi đƣợc cấp phát m ột tài nguyên 
hiện đang b ị một tiến trình khác cũng ở trạng thái blocked ch iếm giữ. Nhƣ v ậy không 
có tiến trình nào có th ể tiếp tục xử lý, cũng nhƣ gi ải phóng tài nguyên cho ti ến trình 
khác s ử dụng, tất cả các ti ến trình trong t ập hợp đều bị khóa vĩnh vi ễn.          Up(s); //đánh th ức P2
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  57    
Hình 5.11. M ột tình hu ống giao thông t ắc ngh ẽn  
5.5.2.  Điều kiện xu ất hiện tắc ngh ẽn  
Để xảy ra t ắc ngh ẽn cần có đ ủ 4 điều kiện sau đây:  
1. Có sử dụng tài nguyên không th ể chia s ẻ (Mutual exclusion): m ỗi thời 
điểm, m ột tài nguyên không th ể chia s ẻ đƣợc hệ thống cấp phát ch ỉ cho 
một tiến trình, khi ti ến trình s ử dụng xong tài nguyên này, h ệ thống m ới 
thu h ồi và c ấp phát tài nguyên cho ti ến trình khác.  
2. Sự chiếm giữ và yêu c ầu thêm tài nguyên (Wait for): các ti ến trình ti ếp 
tục chi ếm giữ các tài nguyên đã c ấp phát cho nó trong khi ch ờ đƣợc cấp 
phát thêm m ột số tài nguyên m ới.  
3. Không th u hồi tài nguyên t ừ tiến trình đang gi ữ chúng (No preemption): 
tài nguyên không th ể đƣợc thu h ồi từ tiến trình đang chi ếm gi ữ chúng 
trƣớc khi ti ến trình này s ử dụng chúng xong.  
4. Tồn tại một chu k ỳ trong đ ồ thị cấp phát tài nguyên (Circular 
wait): có ít nh ất hai ti ến trình ch ờ đợi lẫn nhau: ti ến trình này ch ờ đƣợc 
cấp phát tài nguyên đang b ị tiến trình kia chi ếm giữ và ngƣ ợc lại.  
5.5.3.  Đồ thị cấp phát tài nguyên  
Có th ể sử dụng m ột đồ thị để mô hình hóa vi ệc cấp phát tài nguyên. Đ ồ thị 
này có 2 lo ại nút: các ti ến trình đƣ ợc biểu diễn bằng hình tròn và m ỗi tài 
nguyên đƣ ợc biểu thị bằng hình vuông.  
 Tiến trình P đang gi ữ tài nguyên R   
   
        Tiến trình P đang yêu c ầu tài nguyên R  
P 
  
R 
  
  
   
P 
 R
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  58    
  
           Một tình hu ống tắc ngh ẽn  
 
  
5.5.4.  Các phƣơng pháp x ử lý tắc ngh ẽn 
Chủ yếu có ba hƣ ớng tiếp cận để xử lý tắc ngh ẽn:  
 Sử dụng m ột nghi th ức (Protocol) đ ể đảm bảo rằng hệ thống không bao 
giờ xảy ra t ắc ngh ẽn.  
 Cho phép x ảy ra t ắc ngh ẽn và tìm cách s ửa chữa tắc ngh ẽn.  
 Hoàn toàn b ỏ qua vi ệc xử lý tắc ngh ẽn, xem nhƣ h ệ thống không  bao gi ờ 
xảy ra t ắc ngh ẽn.  
5.5.5.  Tránh t ắc ngh ẽn 
Ngăn c ản là m ột mối bận tâm l ớn khi s ử dụng tài nguyên. C ần phải thực 
hiện những cơ ch ế phức tạp để thực hiện ý đ ịnh này.  
Trạng thái an toàn  
Trạng thái A là an toàn n ếu hệ thống có th ể thỏa mãn các nhu c ầu tài 
nguyên (cho đ ến tối đa) c ủa mỗi tiến trình theo m ột thứ tự nào đó mà v ẫn 
ngăn ch ặn đƣợc tắc ngh ẽn. Một chu ỗi cấp phát an toàn  
Một thứ tự của các ti ến trình <P1, P2, …, Pn> là an toàn đ ối với tình tr ạng 
cấp phát hi ện hành n ếu với mỗi tiến trình Pi nhu c ầu tài nguyên c ủa Pi có 
thể đƣợc thỏa mãn v ới các tài nguyên còn t ự do của hệ thống, c ộng với các 
tài nguyên đang b ị chiếm giữ bởi các ti ến trình P j khác, v ới j<i.  
Một trạng thái an toàn không th ể là một trạng thái t ắc ngh ẽn. Ngƣ ợc lại, 
một trạng thái không an toàn có th ể dẫn đến tình tr ạng tắc ngh ẽn.  
Chiến lược cấp phát  
Chỉ thỏa mãn các yêu c ầu tài nguyên c ủa tiến trình khi tr ạng thái k ết quả là 
an toàn.  
Giải thuật xác đ ịnh tr ạng thái an toàn  
Cần sử dụng các c ấu trúc d ữ liệu sau: 
int Available[NumResourc es];  
// Available[r] = s ố lƣợng các th ể hiện còn t ự do của tài 
nguyên r int Max[NumProcs, NumResources];  
  
R1 
  
P2 
  
R2 
  
P1
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  59  // Max[p, r] = nhu c ầu tối đa c ủa tiến trình p v ề tài 
nguyên r int Allocation[NumProcs, NumResources];  
// Allocation[p, r] = s ố lƣợng tài nguyên r t hực sự cấp phát 
cho p int Need[NumProcs, NumResources];  
// Need[p, r] = Max[p, r] – Allocation[p, r]  
Bƣớc 1: giả sử có các m ảng 
int Work = Available;  
int Finish[NumProcs] = false;  
Bƣớc 2:  
Tìm i sao cho:  
a) Finish[i] == false  
b) Need[i] <=Work[i]  
Nếu khôn g có i nhƣ th ế, đến bƣớc 4  
Bƣớc 3:  
Work = Work + Allocation[i]; 
Finish[i] = true;  
Đến bƣớc 2  
Bƣớc 4:  
Nếu Finish[i] == true v ới mọi i, thì h ệ thống ở trạng thái an toàn.  
Ví dụ  
Giả sử tình tr ạng hi ện hành c ủa hệ thống đƣ ợc mô t ả nhƣ sau:  
  
Tiến 
trình    Max    Allocation     Available    
R1  R2  R3  R1  R2  R3  R1  R2  R3  
P1  3  2  2  1  0  0  
4  1  2  P2  6  1  3  2  1  1  
       
P3  3  1  4  2  1  1     
P4  4  2  2  0  0  2
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  60  Nếu tiến trình P2 yêu c ầu 4 cho R1, 1 cho R3. Hãy cho bi ết yêu c ầu này có th ể 
đáp ứng mà b ảo đảm không x ảy ra tình tr ạng deadlock hay không?  
Nhận thấy Available[1]=4, Available[3]=2 đ ủ để thỏa mãn yêu c ầu của P2, ta có:  
  
Tiến 
trình   Need    Allocation     Available    
R1  R2  R3  R1  R2  R3  R1  R2  R3  
P1  2  2  2  1  0  0  
0  1  1  P2  0  0  1  6  1  2  
P3  1  0  3  2  1  1  
P4  4  2  0  0  0  2  
 
Tiến 
trình   Need    Allocation     Available    
R1  R2  R3  R1  R2  R3  R1  R2  R3  
P1  2  2  2  1  0  0  
6  2  3  P2  0  0  0  0  0  0  
       
P3  1  0  3  2  1  1     
P4  4  2  0  0  0  2  
 
Tiến 
trình   Need    Allocation     Available    
R1  R2  R3  R1  R2  R3  R1  R2  R3  
P1  0  0  0  0  0  0  
7  2  3  P2  0  0  0  0  0  0  
P3  1  0  3  2  1  1  
P4  4  2  0  0  0  2  
  
Tiến 
trình   Need    Allocation     Available    
R1  R2  R3  R1  R2  R3  R1  R2  R3  
P1  0  0  0  0  0  0  
9  3  4  P2  0  0  0  0  0  0  
P3  0  0  0  0  0  0
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  61  P4  4  2  0  0  0  2  
  
Tiến 
trình   Need    Allocation     Available    
R1  R2  R3  R1  R2  R3  R1  R2  R3  
P1  0  0  0  0  0  0  
9  3  6  P2  0  0  0  0  0  0  
P3  0  0  0  0  0  0  
P4  0  0  0  0  0  0  
-> Kết luận: Tr ạng thái k ết quả là an toàn, có th ể cấp phát.  
5.6. QUẢN LÝ B Ộ NHỚ 
5.6.1.  Giới thiệu 
Bộ nhớ chính là thi ết bị lƣu t rữ duy nh ất thông qua đó CPU trao đ ổi dữ liệu 
với môi trƣ ờng ngoài. Do v ậy, nhu c ầu tổ chức, qu ản lý b ộ nhớ là m ột trong 
những nhi ệm vụ trọng tâm hàng đ ầu của hệ điều hành. B ộ nhớ chính đƣ ợc tổ 
chức nhƣ m ột mảng m ột chiều các t ừ nhớ (word), m ỗi từ nhớ có m ột địa chỉ. 
Việc trao đ ổi thông tin v ới môi trƣ ờng ngoài đƣ ợc thực hiện thông qua các thao 
tác đ ọc hoặc ghi d ữ liệu vào m ột địa chỉ cụ thể nào đó trong b ộ nhớ.  
Hầu hết các h ệ điều hành hi ện đại đều cho phép ch ế độ đa nhi ệm nh ằm nâng 
cao hi ệu suất sử dụng CPU. Tuy nhiên k ỹ thuật này l ại làm n ảy sinh nhu c ầu 
chia s ẻ bộ nhớ giữa các ti ến trình khác nhau. V ấn đề nằm ở chỗ “bộ nhớ thì hữu 
hạn và các yêu c ầu bộ nhớ thì vô h ạn”.  
Hệ điều hành có trách nhi ệm cấp phát vùng nh ớ cho các ti ến trình có yêu 
cầu. Để thực hiện tốt nhi ệm vụ này, h ệ điều hành c ần phải xem xét nhi ều khía 
cạnh:  
 Sự tƣơng ứng gi ữa địa chỉ logic và đ ịa chỉ vật lý (physic): làm cách nào đ ể 
chuy ển đổi một địa chỉ tƣợng trƣng (symbolic) trong chƣơng trình thành 
một địa chỉ thực trong b ộ nhớ chính?  
 Quản lý b ộ nhớ vật lý: làm cách nào đ ể mở rộng bộ nhớ có sẵn nhằm lƣu 
trữ đƣợc nhi ều tiến trình đ ồng th ời?  
 Chia s ẻ thông tin: làm th ế nào đ ể cho phép hai ti ến trình có th ể chia s ẻ 
thông tin trong b ộ nhớ?  
 Bảo vệ: làm th ế nào đ ể ngăn ch ặn các ti ến trình x âm ph ạm đến vùng nh ớ 
đƣợc cấp phát cho ti ến trình khác?  
Các đ ịa chỉ trong chƣơng trình ngu ồn là đ ịa chỉ tƣợng trƣng. Vì th ế, một 
chƣơng trình ph ải trải qua nhi ều giai đo ạn xử lý để chuy ển đổi các đ ịa chỉ này 
thành các đ ịa chỉ tuyệt đối trong b ộ nhớ chính.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  62  Có th ể thực hiện kết buộc các ch ỉ thị và dữ liệu với các đ ịa chỉ bộ nhớ vào 
một trong nh ững th ời điểm sau:  
 Thời điểm biên d ịch: n ếu tại thời điểm biên d ịch, có th ể biết vị trí mà ti ến 
trình s ẽ thƣờng trú trong b ộ nhớ, trình biên d ịch có th ể phát sinh ng ay mã 
với các đ ịa chỉ tuyệt đối. Tuy nhiên, n ếu về sau có s ự thay đ ổi vị trí 
thƣờng trú lúc đ ầu của chƣơng trình, c ần phải biên d ịch lại chƣơng trình.  
 Thời điểm nạp: nếu tại thời điểm biên d ịch, chƣa th ể biết vị trí mà ti ến 
trình s ẽ thƣờng trú trong b ộ nhớ, trình biên d ịch cần phát sinh mã tƣơng 
đối (translatable). S ự liên k ết địa chỉ đƣợc trì hoãn đ ến thời điểm chƣơng 
trình đƣ ợc nạp vào b ộ nhớ, lúc này các đ ịa chỉ tƣơng đ ối sẽ đƣợc chuy ển 
thành đ ịa chỉ tuyệt đối do đã bi ết vị trí bắt đầu lƣu tr ữ tiến trìn h. Khi có s ự 
thay đ ổi  
vị trí lƣu tr ữ, chỉ cần nạp lại chƣơng trình đ ể tính toán l ại các đ ịa chỉ tuyệt 
đối mà không c ần biên d ịch lại.  
 Thời điểm xử lý: nếu có nhu c ầu di chuy ển tiến trình t ừ vùng nh ớ này sang 
vùng nh ớ khác trong quá trình ti ến trình x ử lý, thì th ời điểm kết buộc địa 
chỉ phải trì hoãn đ ến tận thời điểm xử lý. Đ ể thực hiện kết buộc địa chỉ 
vào th ời điểm xử lý cần sử dụng cơ ch ế phần cứng đặc biệt.  
Một trong nh ững hƣ ớng ti ếp cận trung tâm nh ằm tổ chức quản lý b ộ nhớ 
một cách hi ệu quả là đƣa ra khái ni ệm không gian đ ịa chỉ đƣợc xây d ựng trên 
không gian nh ớ vật lý, vi ệc tách r ời hai không gian này giúp h ệ điều hành d ễ 
dàng xây d ựng các cơ ch ế và chi ến lƣợc quản lý b ộ nhớ hữu hiệu:  
 Địa chỉ logic: còn g ọi là đ ịa chỉ ảo, là t ất cả các đ ịa chỉ do bộ xử lý tạo ra.  
 Địa chỉ vật lý: là đ ịa chỉ thực tế mà trình qu ản lý b ộ nhớ nhìn th ấy và thao 
tác đƣ ợc.  
 Không gian đ ịa chỉ: là t ập hợp tất cả các đ ịa chỉ ảo phát sinh b ởi một 
chƣơng trình, nói cách khác là vùng đ ịa chỉ mà chƣơng trình có th ể sử 
dụng đƣ ợc.  
 Không gian v ật lý: là t ập hợp tất cả các đ ịa chỉ vật lý tƣơng ứng với các 
địa chỉ ảo.  
Địa chỉ ảo và đ ịa chỉ vật lý là nhƣ nhau trong phƣơng th ức kết buộc địa chỉ 
vào th ời điểm biên d ịch cũng nhƣ vào th ời điểm nạp. Nhƣng có s ự khác bi ệt giữa 
địa chỉ ảo và địa chỉ vật lý trong phƣơng th ức kết buộc vào th ời điểm xử lý.  
MMU (Memory Management Unit) là m ột cơ ch ế phần cứng đƣ ợc sử dụng 
để thực hiện chuy ển đổi địa chỉ ảo thành đ ịa chỉ vật lý vào th ời điểm xử lý.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  63  Chƣơng trình c ủa ngƣ ời sử dụng ch ỉ thao tác t rên các đ ịa chỉ ảo, không bao 
giờ nhìn th ấy các đ ịa chỉ vật lý. Đ ịa chỉ thật sự ứng với vị trí của dữ liệu trong b ộ 
nhớ chỉ đƣợc xác đ ịnh khi th ực hiện truy xu ất đến dữ liệu.  
5.6.2.  Phân trang (paging)  
Ý tƣ ởng:  
Phân b ộ nhớ vật lý thành các kh ối (block) có kích thƣớc cố định và b ằng 
nhau, g ọi là khung trang (page frame). Không gian đ ịa chỉ cũng đƣ ợc chia thành 
các kh ối có cùng kích thƣ ớc với khung trang, và đƣ ợc gọi là trang (page). Khi 
cần nạp một tiến trình đ ể xử lý, các trang c ủa tiến trình s ẽ đƣợc nạp vào nh ững 
khung trang còn tr ống. M ột tiến trình kích thƣ ớc N trang s ẽ yêu c ầu N khung 
trang t ự do.  
Cơ ch ế MMU trong k ỹ thuật phân trang  
 Cơ ch ế phần cứng hỗ trợ thực hiện chuy ển đổi địa chỉ trong cơ ch ế phân 
trang là b ảng trang (pages table). M ỗi phần tử trong b ảng trang cho bi ết các đ ịa 
chỉ bắt đầu của vị trí lƣu tr ữ trang tƣơng ứng trong b ộ nhớ vật lý (s ố hiệu khung 
trang trong b ộ nhớ vật lý đang ch ứa trang).  
Chuy ển đổi địa chỉ  
Mỗi địa chỉ phát sinh b ởi CPU đƣ ợc chia thành hai ph ần:  
 Số hiệu trang (p): s ử dụng nhƣ ch ỉ mục đến ph ần tử tƣơng ứng trong 
bảng trang.  
 Địa chỉ tƣơng đ ối trong trang (d): k ết hợp với địa chỉ bắt đầu của trang 
để tạo ra đ ịa chỉ vật lý mà trình qu ản lý b ộ nhớ sử dụng.  
 
Kích thƣ ớc của trang do ph ần cứng quy đ ịnh. Đ ể dễ phân tích đ ịa chỉ ảo 
thành s ố hiệu trang và đ ịa chỉ tƣơng đ ối, kích thƣ ớc của một trang thông thƣ ờng 
  
Hình 5.11 .  
Mô hình  
bộ nhớ phân trang  
  
Page 0  
  
Page 1  
  
Page 2  
  
Page 3  
  
Page 1  
  
  
Page 0  
  
Page 3  
  
  
  
Page 2  
  
  
Không gian đ ịa chỉ 
  
Không gian v ật lý
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  64  là một lũy th ừa của 2 (bi ến đổi trong ph ạm vi 512 bytes và 8192 bytes). N ếu 
kích thƣ ớc của không gian đ ịa chỉ là 2m và kích thƣ ớc trang là 2n thì m -n bits 
cao c ủa địa chỉ ảo sẽ biểu diễn số hiệu trang, và n bits th ấp cho bi ết địa chỉ tƣơng 
đối trong trang.  
 
    
 
 
Hình 5.12. Cơ ch ế phần cứng h ỗ trợ phân trang  
  
  
  
  
  
  
  
  
  
  
  
CPU  
  
p 
  
d 
  
 f 
  
d 
  
  
  
  
f 
  
  
p 
  
  
  
  
  
  
Bộ nhớ 
  
vật lý 
  
Địa  
chỉ logic  
  
 Địa chỉ physic  
  
p 
  
  
 d 
  
m  
- 
  
n 
  
 n
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  65   
Hình 5.13. Ví d ụ phân trang v ới bộ nhớ 32 byte, kích thư ớc trang là 4 byte  
Cài đ ặt bảng trang  
Trong trƣ ờng hợp đơn gi ản nhất, bảng trang là m ột tập các thanh ghi đƣ ợc 
sử dụng để cài đ ặt bảng trang. Tuy nhiên vi ệc sử dụng thanh ghi ch ỉ phù h ợp 
với các b ảng trang có kích thƣ ớc nhỏ, nếu bảng trang có kích thƣ ớc lớn, nó 
phải đƣợc lƣu tr ữ trong b ộ nhớ chính và s ử dụng một thanh ghi đ ể lƣu đ ịa chỉ 
bắt đầu lƣu tr ữ bảng trang (PTBR).  
Theo cách t ổ chức này, m ỗi lần truy xu ất đến dữ liệu hay ch ỉ thị đều đòi 
hỏi hai l ần truy xu ất bộ nhớ: một cho truy xu ất đến bảng trang và m ột cho b ản 
thân d ữ liệu.  
Có th ể né tránh b ớt việc truy xu ất bộ nhớ hai lần bằng cách s ử dụng thêm 
một vùng nh ớ đặc biệt, với tốc độ truy xu ất nhanh và cho phép tìm ki ếm song 
song. Vùng nh ớ cache nh ỏ này thƣ ờng đƣ ợc gọi là b ộ nhớ kết hợp (TBLs). M ỗi 
thanh ghi trong b ộ nhớ kết hợp gồm một từ khóa và m ột giá trị, khi đƣa đ ến bộ 
nhớ kết hợp một đối tƣợng cần tìm, đ ối tƣợng này s ẽ đƣợc so sánh cùng lúc v ới 
các t ừ khóa trong b ộ nhớ kết hợp để tìm ra ph ần tử tƣơng ứng. Nh ờ đặc tính 
này mà vi ệc tìm ki ếm trên b ộ nhớ kết hợp đƣợc thực hiện rất nhanh, nhƣng chi 
phí phần cứng lại cao.  
Trong k ỹ thuật phân trang, TBLs đƣ ợc sử dụng để lƣu tr ữ các trang b ộ nhớ 
đƣợc truy c ập gần hiện tại nhất. Khi CPU phát sinh m ột địa chỉ, số hiệu trang
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  66  của địa chỉ sẽ đƣợc so sánh v ới các ph ần tử trong TBLs, n ếu có trang tƣơng 
ứng trong TBLs thì s ẽ xác đ ịnh đƣ ợc ngay s ố hiệu khung trang tƣơng ứng, n ếu 
không m ới cần thực hiện thao tác tìm ki ếm trong b ảng trang.  
  
Hình 5.14. Ph ần cứng h ỗ trợ phân trang s ử dụng TBLs  
Tổ chức bảng trang  
Mỗi hệ điều hành có m ột phƣơng pháp riêng đ ể tổ chức lƣu tr ữ bảng trang. Đa s ố 
các h ệ điều hành c ấp cho m ỗi tiến trình m ột bảng trang. Tuy nhiên, phƣơng pháp này 
không th ể chấp nhận đƣợc nếu hệ điều hành qu ản lý m ột không gian đ ịa chỉ có dung 
lƣợng quá l ớn (232, 264): trong các h ệ thống nhƣ th ế, bản thân b ảng trang đòi h ỏi một 
vùng nh ớ quá l ớn! Có hai gi ải pháp cho v ấn đề này:  
 Phân trang đa c ấp: phân chia b ảng trang thành các ph ần nhỏ, bản thân b ảng 
trang cũng s ẽ đƣợc phân trang.  
 Bảng trang ngh ịch đảo (Inverted page table): s ử dụng duy nh ất một bảng 
trang ng hịch đảo cho t ất cả các ti ến trình. M ỗi phần tử trong b ảng trang 
nghịch đảo phản ánh m ột khung trang trong b ộ nhớ bao g ồm địa chỉ logic 
của một trang đang đƣ ợc lƣu tr ữ trong b ộ nhớ vật lý t ại khung trang này, 
cùng v ới thông tin v ề tiến trình đang đƣ ợc sở hữu trang. M ỗi địa chỉ ảo khi 
đó là m ột bộ ba <idp, p, d>, trong đó:  
 idp là đ ịnh danh c ủa tiến trình.  
 p là s ố hiệu trang.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  67   d là đ ịa chỉ tƣơng đ ối trong trang.  
Mỗi phần tử trong b ảng trang ngh ịch đảo là m ột cặp <idp, p>. Khi m ột tham kh ảo 
đến bộ nhớ đƣợc phát sinh, m ột phần địa chỉ ảo là <idp, p> đƣ ợc đƣa đ ến cho trình 
quản lý b ộ nhớ để tìm ph ần tử tƣơng ứng trong b ảng trang ngh ịch đảo. Nếu tìm th ấy 
địa chỉ vật lý <i,d> s ẽ đƣợc phát sinh. Trong các trƣ ờng hợp khác, xem nhƣ tham kh ảo 
bộ nhớ đã truy xu ất một địa chỉ bất hợp lệ.  
  
Hình 5.15. B ảng trang ngh ịch đảo  
5.6.3.  Phân đoạn 
Ý tƣ ởng 
Quan ni ệm không gian đ ịa chỉ là m ột tập các phân đo ạn (segments). Các phân 
đoạn là nh ững ph ần bộ nhớ kích thƣ ớc khác nhau và có liên h ệ logic v ới nhau. M ỗi 
phân đo ạn có m ột tên g ọi (số hiệu phân đo ạn) và có m ột độ dài. Ngƣ ời dùng s ẽ thiết 
lập mỗi địa chỉ với hai giá tr ị: <số hiệu phân đo ạn, offset>  
Cơ ch ế MMU  
Cần phải xây d ựng m ột ánh x ạ để chuy ển đổi các đ ịa chỉ 2 chi ều đƣợc ngƣ ời dùng 
định nghĩa thành đ ịa chỉ vật lý m ột chiều. Sự chuy ển đổi này đƣ ợc thực hiện qua m ột 
bảng phân đo ạn. M ỗi thành ph ần trong b ảng phân đo ạn bao g ồm một thanh ghi n ền và 
một thanh ghi gi ới hạn. Thanh ghi n ền lƣu tr ữ địa chỉ vật lý nơi b ắt đầu phân đo ạn 
trong b ộ nhớ. Trong khi thanh ghi gi ới hạn đặc tả chiều dài c ủa phân đo ạn.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  68   
Chuy ển đổi địa chỉ 
Mỗi địa chỉ ảo là m ột bộ <s, d>:  
 Số hiệu phân đo ạn s : đƣ ợc sử dụng nhƣ ch ỉ mục đến bảng phân đo ạn. 
 Địa chỉ tƣơng đ ối d : có giá tr ị từ 0 đến giới hạn chi ều dài c ủa phân 
đoạn. Nếu địa chỉ tƣơng đ ối hợp lệ, nó s ẽ đƣợc cộng với giá tr ị chứa trong 
thanh ghi n ền để phát sinh đ ịa chỉ vật lý tƣơng ứng.  
  
 
Hình 5.16  
.  
Một mô hình phân đo ạn bộ nhớ 
  
Bảng ký  
hiệu 
  
Stack  
  
Chương  
trình con  
  
Chương  
trình chính  
  
Không gian đ ịa chỉ 
  
 Không gian v ật lý 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
Hình 5.17  
.  
Cơ ch ế phần cứng h ỗ trợ phân đo ạn 
  
CPU  
  
s 
  
d 
  
s 
  
  
  
  
  
  
Bộ nhớ 
  
vật lý 
  
< 
  
 + 
  
  
   
limit 
  
base  
  
  
   
Bảng phân đo ạn 
  
đúng  
  
sai 
  
Lỗi địa chỉ
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  69  Cài đ ặt bảng phân đo ạn 
Có th ể sử dụng các thanh ghi đ ể lƣu tr ữ bảng phân đo ạn nếu số lƣợng phân đo ạn 
nhỏ. Trong trƣ ờng hợp chƣơng trình bao g ồm quá nhi ều phân đo ạn, bảng phân đo ạn 
phải đƣợc lƣu trong b ộ nhớ chính. M ột thanh ghi n ền bảng phân đo ạn (STBR) ch ỉ đến 
địa chỉ bắt đầu của bảng phân đo ạn. Vì s ố lƣợng phân đo ạn sử dụng trong m ột chƣơng 
trình bi ến động, c ần sử dụng thêm m ột thanh ghi đ ặc tả kích thƣ ớc bảng phâ n đoạn 
(STLR).  
Với một địa chỉ logic <s, d>, trƣ ớc tiên s ố hiệu phân đo ạn s đƣ ợc kiểm tra tính 
hợp lệ (s<STLR). K ế tiếp, cộng giá tr ị s với STBR đ ể có đƣ ợc địa chỉ của phần tử thứ 
s trong b ảng phân đo ạn (STBR + s). Đ ịa chỉ vật lý cu ối cùng là (STBR + s +d ).  
Cũng nhƣ đ ối với kỹ thuật phân trang, có th ể nâng t ốc độ truy xu ất bộ nhớ bằng 
cách s ử dụng TBLs đ ể lƣu tr ữ các ph ần tử trong b ảng trang đƣ ợc truy c ập gần nhất.  
  
  
Hình 5. 18. Ví d ụ một trƣ ờng hợp phân đo ạn  
5.6.4.  Phân trang k ết hợp phân đo ạn  
Ý tƣ ởng
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  70  Không gian đ ịa chỉ là m ột tập các phân đo ạn, m ỗi phân đo ạn đƣ ợc chia thành 
nhiều trang. Khi m ột tiến trình đƣ ợc đƣa vào h ệ thống, h ệ điều hành s ẽ cấp phát cho 
tiến trình các trang c ần thiết để chứa đủ các phân đo ạn của tiến trình.  
Cơ ch ế MMU  
Để hỗ trợ kỹ thuật phân đo ạn, cần phải có m ột bảng phân đo ạn, nhƣng gi ờ đây 
mỗi phân đo ạn cần có m ột bảng trang riêng bi ệt.  
Chuy ển đổi địa chỉ  
Mỗi địa chỉ logic là m ột bộ ba: <s, p, d>  
 Số hiệu phân đo ạn s : s ử dụng nhƣ ch ỉ mục đến phần tử tƣơng ứng trong 
bảng phân đo ạn.  
 Số hiệu trang p : s ử dụng nhƣ ch ỉ mục đến phần tử tƣơng ứng trong b ảng 
trang c ủa phân đo ạn.  
 Địa chỉ tƣơng đ ối trong trang d : k ết hợp với địa chỉ bắt đầu của trang đ ể 
tạo ra đ ịa chỉ vật lý mà trình qu ản lý b ộ nhớ sử dụng.  
 
Hình 5. 19. Mô hình phân đo ạn kết hợp phân trang  
 Tất cả các mô hình t ổ chức bộ nhớ ở trên đ ều có khuynh hư ớng cấp phát cho ti ến 
trình toàn b ộ các trang yêu c ầu trư ớc khi th ật sự xử lý. Vì b ộ nhớ vật lý có kích 
thước rất giới hạn, điều này d ẫn đến hai đi ểm bất tiện sau:  
 Kích thư ớc tiến trình b ị giới hạn bởi kích thư ớc của bộ nhớ vật lý.  
 Khó có th ể duy trì nhi ều tiến trình cùng lúc trong b ộ nhớ, và như v ậy khó 
nâng cao m ức độ đa chương c ủa hệ thống.  
5.6.5.  Bộ nhớ ảo (virtual memory)  
Giới thiệu  
Bảng ký  
hiệu 
  
Stack  
  
Chương  
trình con  
  
Chương  
trình chính  
  
Không gian đ ịa chỉ 
  
Không gian vât lý
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  71  Nếu đặt toàn th ể không gian đ ịa chỉ vào b ộ nhớ vật lý, thì kích thƣ ớc của chƣơng 
trình b ị giới hạn bởi kích thƣ ớc bộ nhớ vật lý. Th ực tế, trong nhi ều trƣ ờng hợp, chúng 
ta không c ần phải nạp toàn b ộ chƣơng trình vào b ộ nhớ vật lý cùng m ột lúc, vì t ại mỗi 
thời điểm ch ỉ có m ột chỉ thị của tiến trình đƣợc xử lý. Ví d ụ: các chƣơng trình đ ều có 
đoạn code x ử lý lỗi, nhƣng đo ạn code này h ầu nhƣ r ất ít khi đƣ ợc sử dụng vì hi ếm khi 
xảy ra l ỗi, trong trƣ ờng hợp này không c ần thiết phải nạp đoạn code x ử lý lỗi từ đầu.  
Từ nhận xét trên, m ột giải pháp đƣ ợc đề xuất là cho phép th ực hiện một chƣơng 
trình ch ỉ đƣợc nạp từng ph ần vào b ộ nhớ vật lý. Ý tƣ ởng chính c ủa giải pháp này là t ại 
mỗi thời điểm ch ỉ lƣu tr ữ trong b ộ nhớ vật lý các ch ỉ thị và dữ liệu của chƣơng trình 
cần thi ết cho vi ệc thi hành t ại thời điểm đó. Khi c ần đến các ch ỉ thị khác, nh ững ch ỉ 
thị mới sẽ đƣợc nạp vào b ộ nhớ tại vị trí trƣ ớc đó b ị chiếm gi ữ bởi các ch ỉ thị nay 
không còn c ần đến nữa. Với giải pháp này, m ột chƣơng trình có th ể lớn hơn kích 
thƣớc của vùng nh ớ cấp phát cho nó.  
Một cách th ể hiện ý tƣ ởng của giải pháp này là k ỹ thuật overlay. K ỹ thuật overlay 
không đòi h ỏi bất kỳ sự trợ giúp đ ặc biệt nào c ủa hệ điều hành. Nhƣng trái l ại lập trình  
viên ph ải biết cách l ập trình theo c ấu trúc overlay và đi ều này đòi h ỏi khá nhi ều công 
sức.  
Để giải phóng l ập trình viên kh ỏi các suy tƣ v ề giới hạn của bộ nhớ, mà cũng 
không tăng thêm khó khăn cho công vi ệc lập trình c ủa họ, ngƣ ời ta nghĩ đ ến các k ỹ 
thuật tự động cho phép x ử lý m ột chƣơng trình có kích thƣ ớc lớn chỉ với một vùng 
nhớ có kích thƣ ớc nhỏ. Giải pháp đƣ ợc tìm th ấy với khái ni ệm bộ nhớ ảo (Virtual 
Memory).  
Khái ni ệm  
Bộ nhớ ảo là m ột kỹ thuật cho phép x ử lý một tiến trình không đƣ ợc nạp toàn b ộ 
vào b ộ nhớ vật lý. B ộ nhớ ảo mô hình hóa b ộ nhớ nhƣ m ột bảng lƣu tr ữ rất lớn và 
đồng nh ất, tách bi ệt hẳn khái ni ệm không gian đ ịa chỉ và không gian v ật lý. Ngƣ ời sử 
dụng ch ỉ nhìn th ấy và làm vi ệc trong không gian đ ịa chỉ ảo, vi ệc chuy ển đổi sang 
không gian v ật lý do h ệ điều hành th ực hiện với sự trợ giúp c ủa các cơ ch ế phần cứng 
cụ thể.  
Thảo luận  
Cần kết hợp kỹ thuật swapping đ ể chuy ển các ph ần của chƣơng trình vào ra gi ữa 
bộ nhớ chính và b ộ nhớ phụ khi c ần thiết.  
Nhờ việc tách bi ệt bộ nhớ ảo và b ộ nhớ vật lý, có th ể tổ chức một bộ nhớ ảo có 
kích thƣ ớc lớn hơn b ộ nhớ vật lý.  
Bộ nhớ ảo cho phép gi ảm nhẹ công vi ệc của lập trình viên vì h ọ không c ần bận 
tâm đ ến giới hạn của vùng nh ớ vật lý, cũng nhƣ không c ần tổ chức chƣơng trình theo 
cấu trúc overlay.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  72   
Hình 5. 20. Mô hình b ộ nhớ ảo 
Cài đ ặt bộ nhớ ảo  
Bộ nhớ ảo thƣ ờng đƣ ợc thực hiện với kỹ thuật phân trang theo yêu c ầu (demand 
paging). Cũng có th ể sử dụng kỹ thuật phân đo ạn theo yêu c ầu (demand segmentation) 
để cài đ ặt bộ nhớ ảo. Tuy nhiên, vi ệc cấp phát và thay th ế các phân đo ạn phức tạp hơn 
thao tác trên trang vì kích thƣ ớc không b ằng nhau c ủa các  đoạn.  
Phân trang theo yêu c ầu (demand paging)  
Một hệ thống phân trang theo yêu c ầu là h ệ thống sử dụng k ỹ thuật swapping. 
Một tiến trình đƣ ợc xem nhƣ m ột tập các trang, thƣ ờng trú trên b ộ nhớ phụ (thƣờng là 
đĩa). Khi c ần xử lý, ti ến trình s ẽ đƣợc nạp vào bộ nhớ chính. Nhƣng thay vì n ạp toàn 
bộ chƣơng trình, ch ỉ những trang c ần thiết trong th ời điểm hiện tại mới đƣợc nạp vào 
bộ nhớ. Nhƣ v ậy, một trang ch ỉ đƣợc nạp vào b ộ nhớ chính khi có yêu c ầu.  
Với mô hình này, c ần cung c ấp một cơ ch ế phần cứng giúp ph ân bi ệt các trang ở 
trong b ộ nhớ chính và các trang trên đĩa. Có th ể sử dụng lại bit valid -invalid nhƣng 
với ngữ nghĩa m ới:  
 valid: trang tƣơng ứng là h ợp lệ và đang ở trong b ộ nhớ chính.  
 invalid: ho ặc trang b ất hợp lệ (không thu ộc về không gian đ ịa chỉ của tiến 
trình) ho ặc trang h ợp lệ nhƣng đang đƣ ợc lƣu trên b ộ nhớ phụ.  
Một phần tử trong b ảng trang mô t ả cho m ột trang không n ằm trong b ộ nhớ chính 
sẽ đƣợc đánh d ấu invalid và ch ứa địa chỉ của trang trên b ộ nhớ phụ.  
  
  
  
  
  
  
  
Bộ nhớ ảo 
  
 MMU  
  
Bộ nhớ  
chính  
  
Bộ nhớ phụ
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  73   
Hình 5. 21. Bảng trang c ủa một trƣ ờng hợp phân trang theo yêu c ầu  
Cơ ch ế MMU  
Cơ ch ế phần cứng hỗ trợ kỹ thuật phân trang theo yêu c ầu là s ự kết hợp của cơ 
chế hỗ trợ kỹ thuật phân trang và k ỹ thuật swapping.  
 Bảng trang: c ấu trúc b ảng trang ph ải cho phép ph ản ánh tình tr ạng của một 
trang l à đang n ằm trong b ộ nhớ chính hay b ộ nhớ phụ.  
 Bộ nhớ phụ: bộ nhớ phụ lƣu tr ữ những trang không đƣ ợc nạp vào b ộ nhớ 
chính. B ộ nhớ phụ thƣờng đƣ ợc sử dụng là đĩa và là vùng không gian đĩa 
dùng đ ể lƣu tr ữ tạm các trang trong k ỹ thuật swapping đƣ ợc gọi là khô ng 
gian swapping.  
Lỗi trang  
Truy xu ất đến một trang đƣ ợc đánh d ấu bất hợp lệ sẽ làm phát sinh m ột lỗi trang 
(page fault). Khi dò tìm trong b ảng trang đ ể lấy các thông tin c ần thi ết cho vi ệc 
chuy ển đổi địa chỉ, nếu nhận thấy trang đang đƣ ợc yêu c ầu truy x uất là b ất hợp lệ, cơ
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  74  chế phần cứng sẽ phát sinh m ột ngắt để báo cho h ệ điều hành. H ệ điều hành s ẽ xử lý 
lỗi trang nhƣ sau:  
1. Kiểm tra truy xu ất đến bộ nhớ có hợp lệ hay không?  
2. Nếu truy xu ất bất hợp lệ thì kết thúc ti ến trình. Ngƣ ợc lại thì đ ến bƣớc 
3.  
3. Tìm vị trí ch ứa trang mu ốn truy xu ất trên đĩa.  
4. Tìm m ột khung trang tr ống trong b ộ nhớ chính  
a. Nếu tìm th ấy: đến bƣớc 5  
b. Nếu không còn khung trang tr ống, ch ọn một khung trang “n ạn 
nhân” và chuy ển trang “n ạn nhân” ra b ộ nhớ phụ (lƣu n ội dung 
của trang đang chi ếm gi ữ khung trang này lên đĩa), c ập nh ật 
bảng trang tƣơng ứng rồi đến bƣớc 5.  
5. Chuy ển trang mu ốn truy xu ất từ bộ nhớ phụ vào b ộ nhớ chính: n ạp 
trang c ần truy xu ất vào khung trang tr ống đã ch ọn (hay v ừa mới làm 
trống), c ập nhật nội dung b ảng trang, b ảng kh ung trang tƣơng ứng.  
6. Tái kích ho ạt tiến trình ngƣ ời sử dụng.  
 
Hình 5.2 2. Sơ đ ồ các bƣ ớc xử lý lỗi trang  
Thay th ế trang
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  75  Khi x ảy ra m ột lỗi trang, c ần phải mang trang v ắng m ặt vào b ộ nhớ. Nếu không 
có m ột khung trang nào tr ống, h ệ điều hành c ần thực hiện công vi ệc thay th ế trang – 
chọn một trang đang n ằm trong b ộ nhớ mà không đƣ ợc sử dụng tại thời điểm hiện tại 
và chuy ển nó ra không gian swapping trên đĩa đ ể giải phóng m ột khung trang dành 
chỗ nạp trang c ần truy xu ất vào b ộ nhớ.  
Nhƣ v ậy, nếu không có k hung trang tr ống thì m ỗi khi x ảy ra l ỗi trang c ần phải 
thực hiện hai thao tác chuy ển trang: chuy ển một trang ra b ộ nhớ phụ và nạp một trang 
khác vào b ộ nhớ chính. Có th ể giảm bớt số lần chuy ển trang b ằng cách s ử dụng thêm 
một bit c ập nhật (dirty bit). Bit này đƣ ợc gắn với mỗi trang đ ể phản ánh tình tr ạng 
trang có b ị cập nhật hay không. Giá tr ị của bit đƣ ợc cơ ch ế phần cứng đặt là 1 m ỗi lần 
có m ột từ đƣợc ghi vào trang đ ể ghi nh ận nội dung trang có b ị sửa đổi. Khi c ần thay 
thế một trang, n ếu bit c ập nhật có giá tr ị là 1 thì trang c ần đƣợc lƣu l ại trên đĩa, ngƣ ợc 
lại thì không c ần lƣu tr ữ trang tr ở lại đĩa.  
Vấn đề chính khi thay th ế trang là ch ọn lựa một trang “n ạn nhân” đ ể chuy ển ra b ộ 
nhớ phụ. Có nhi ều thu ật toán thay th ế trang khác nhau, nhƣng t ất cả cùng chung m ột 
mục tiêu: ch ọn trang “n ạn nhân” là trang mà sau khi thay th ế sẽ xảy ra ít l ỗi trang 
nhất. Có th ể đánh giá hi ệu quả của một thuật toán b ằng cách x ử lý trên m ột chu ỗi các 
địa chỉ cần truy xu ất và tính toán s ố lỗi trang phát sinh.  
Ví dụ: giả sử theo vết xử lý của một tiến trình và nh ận thấy tiến trình th ực hiện 
truy xu ất các đ ịa chỉ theo th ứ tự sau:  
0100, 0423, 0101, 0162, 0102, 0103, 0104, 0101, 0611, 0102, 0103, 0104, 0101, 
0610, 0102, 0103, 0104, 0101, 0609, 0102, 0105  
Nếu có kích thƣ ớc của một trang là 100 bytes, có th ể viết lại chu ỗi truy xu ất trên 
giản lƣợc hơn nhƣ sau:  
 1, 4, 1, 6, 1, 6, 1, 6, 1  
Để xác đ ịnh số lỗi trang x ảy ra khi s ử dụng m ột thuật toán thay th ế trang nào đó 
trên m ột chu ỗi truy xu ất cụ thể, còn c ần phải biết số lƣợng khung  trang s ử dụng trong 
hệ thống.  
Để minh h ọa các thu ật toán thay th ế trang s ẽ trình bày, chu ỗi truy xu ất đƣợc sử 
dụng là:  
 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1  
 Thuật toán FIFO  
Giải thu ật: ghi nh ận thời điểm một trang đƣ ợc mang vào bộ nhớ chính. Khi c ần 
thay th ế trang, trang ở trong b ộ nhớ lâu nh ất sẽ đƣợc chọn.  
Ví dụ: sử dụng 3 khung trang, ban đ ầu cả 3 đều trống  
7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1  
7  7  7  2  2  2  2  4  4  4  0  0  0  0  0  0  0  7  7  7  
  0  0  0  0  3  3  3  2  2  2  2  2  1  1  1  1  1  0  0
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  76      1  1  1  1  0  0  0  3  3  3  3  3  2  2  2  2  2  1  
*  *  *  *    *  *  *  *  *  *      *  *      *  *  *  
Ghi chú:  ký hi ệu * : có l ỗi trang  
Thảo luận:  
Để áp dụng thu ật toán FIFO, th ực tế không nh ất thiết phải ghi nh ận thời điểm mỗi 
trang đƣ ợc nạp vào b ộ nhớ, mà ch ỉ cần tổ chức quản lý các trang trong b ộ nhớ trong 
một danh sách FIFO, khi đó trang đ ầu danh sách s ẽ đƣợc chọn để thay th ế.  
Thuật toán thay th ế trang FIFO d ễ hiểu, dễ cài đ ặt. Tuy nhiên khi th ực hiện không 
phải lúc nào cũng có k ết quả tốt: trang đƣ ợc chọn để thay th ế có th ể là trang ch ứa 
nhiều dữ liệu cần thiết, thƣ ờng xuyên đƣ ợc sử dụng nên đƣ ợc nạp sớm. Do v ậy, khi di 
chuy ển ra b ộ nhớ phụ sẽ nhanh chóng gây ra l ỗi trang.  
Số lƣợng lỗi trang x ảy ra s ẽ tăng lên khi s ố lƣợng khung trang s ử dụng tăng. Hi ện 
tƣợng này g ọi là ngh ịch lý Belady.  
 Thuật toán t ối ưu  
Giải thu ật: thay th ế trang s ẽ lâu đƣ ợc sử dụng nh ất trong tƣơng lai.  
Ví dụ: sử dụng 3 khung trang, kh ởi đầu đều trống:   
 7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1  
7  7  7  2  2  2  2  2  2  2  2  2  2  2  2  2  2  7  7  7  
  0  0  0  0  0  0  4  4  4  0  0  0  0  0  0  0  0  0  0  
    1  1  1  3  3  3  3  3  3  3  3  1  1  1  1  1  1  1  
*  *  *  *    *    *      *     
 *        *      
Thảo luận: thuật toán này đ ảm bảo số lƣợng lỗi trang phát sinh là th ấp nhất, nó 
cũng không gánh ch ịu ngh ịch lý Belady. Tuy nhiên, đây là m ột thuật toán không kh ả 
thi trong th ực tế, vì không th ể biết trƣớc chu ỗi truy xu ất của tiến trình.  
Thuật toán LRU (Least -Recently -Used)  
Giải thuât:  với mỗi trang, ghi nh ận thời điểm cu ối cùng trang đƣ ợc truy c ập, 
trang đƣ ợc chọn để thay th ế sẽ là trang lâu nh ất chƣa đƣ ợc truy xu ất.  
Ví dụ: sử dụng 3 khung trang, kh ởi đầu đều trống:  
 7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1  
7  7  7  2  2  2  2  4  4  4  0  0  0  1  1  1  1  1  1  1  
  0  0  0  0  0  0  0  0  3  3  3  3  3  3  0  0  0  0  0  
    1  1  1  3  3  3  2  2  2  2  2  2  2  2  2  7  7  7  
*  *  *  *    *    *  *  *  *     
 *    *    *
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  77  Thảo luận:  
Thuật toán FIFO s ử dụng th ời điểm nạp để chọn trang thay th ế, thuật toán t ối ƣu 
lại dùng th ời điểm trang s ẽ đƣợc sử dụng. Vì th ời điểm này không th ể xác đ ịnh trƣ ớc 
nên thu ật toán LRU ph ải dùng th ời điểm cu ối cùng trang đƣ ợc truy xu ất – dùng quá 
khứ gần để dự đoán tƣơng lai.  
Thuật toán này đòi h ỏi phải đƣợc cơ ch ế phần cứng hỗ trợ để xác đ ịnh m ột thứ tự 
cho các trang theo th ời điểm truy xu ất cuối cùng. Có th ể cài đ ặt theo m ột trong hai 
cách: 1.  Sử dụng bộ đếm  
 Thêm vào c ấu trúc c ủa mỗi phần tử trong b ảng trang m ột trƣờng ghi nh ận 
thời điểm truy xu ất mới nhất, và thêm vào c ấu trúc c ủa CPU m ột bộ đếm.  
 Mỗi lần có s ự truy xu ất bộ nhớ, giá tr ị của counter tăng lên 1.  
 Mỗi lần thực hiện truy xu ất đến một trang, giá t rị của counter đƣ ợc ghi 
nhận vào trƣ ờng th ời điểm truy xu ất mới nhất của phần tử tƣơng ứng với 
bảng trang trong b ảng trang.  
 Thay th ế trang có giá tr ị trƣờng th ời điểm truy xu ất mới nhất là nh ỏ nhất.  
2. Sử dụng Stack  
 Tổ chức một stack lƣu tr ữ các s ố hiệu trang.  
 Mỗi khi th ực hiện một truy xu ất đến một trang, s ố hiệu của trang s ẽ đƣợc 
xóa kh ỏi vị trí hi ện hành trong stack và đƣa lên đ ầu stack.  
 Trang ở đỉnh stack là trang đƣ ợc truy xu ất gần nhất và trang ở đáy stack là 
trang lâu nh ất chƣa đƣ ợc sử dụng.  
5.6.6.  Cấp phát khung và thay th ế trang  
Với mỗi tiến trình, c ần phải cấp phát m ột số lƣợng khung trang t ối thiểu nào đó đ ể 
tiến trình có th ể hoạt động. S ố khung trang t ối thiểu này đƣ ợc quy đ ịnh bởi kiến trúc 
của máy tính.   
Ví dụ: với máy IBM 370, đ ể lệnh MOVE có  thể thực hiện thì t ối thiểu phải có 2 
trang: m ột trang ngu ồn (from), m ột trang đích (to). Khi m ột lỗi trang x ảy ra trƣ ớc khi 
chỉ thị hiện hành hoàn t ất, chỉ thị đó cần đƣợc tái kh ởi động, lúc đó c ần phải có đ ủ các 
khung trang đ ể nạp tất cả các trang mà m ột chỉ thị cần sử dụng.   
Số khung trang t ối thiểu đƣợc quy đ ịnh bởi kiến trúc máy tính, trong khi s ố khung 
trang t ối đa đƣ ợc xác đ ịnh bởi dung lƣ ợng bộ nhớ vật lý có th ể sử dụng.  
Cấp phát s ố khung trang  
Có ba cách c ấp phát s ố lƣợng khung trang là:   
 Cấp phát ngang b ằng (Equal Allocation)  
 Cấp phát theo t ỷ lệ kích thƣ ớc (Proportional Allocation)
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  78   Cấp phát theo đ ộ ƣu tiên (Priority Allocation)  
a) Cấp phát ngang b ằng  
Nếu có m khung trang và n ti ến trình, m ỗi tiến trình đƣ ợc cấp m/n khung trang. 
Phƣơng pháp nà y đơn gi ản nhƣng không hi ệu quả.  
b) Cấp phát theo t ỷ lệ kích thư ớc  
Tùy vào kích thƣ ớc của tiến trình đ ể cấp phát s ố khung trang. G ọi:  
si là kích thƣ ớc của tiến trình pi  
  𝑆 = ∑ 𝑠𝑖 là tổng kích thƣ ớc của tất cả tiến trình m 
là số lƣợng khung trang có th ể sử dụng  
Khi đó, ti ến trình pi s ẽ đƣợc cấp phát ai khung trang. V ới:  
    
Ví d ụ: có 2 ti ến trình, ti ến trình 1 có kích thƣ ớc 10K, ti ến trình 2 là 127K, h ệ 
thống có 62 khung trang tr ống. Khi đó, có th ể cấp cho các ti ến trình là:  
- Tiến trình 1: 10/137 x 6 2 ~ 4 khung  
- Tiến trình 2: 127/137 x 62 ~ 57 khung  
c) Cấp phát theo đ ộ ưu tiên  
Số lƣợng khung trang c ấp cho ti ến trình ph ụ thuộc vào đ ộ ƣu tiên c ủa tiến trình. 
Tiến trình có đ ộ ƣu tiên cao s ẽ đƣợc cấp nhi ều khung hơn đ ể tăng t ốc độ thực hiện.  
Thay th ế trang  
Có hai cách đ ể thay th ế trang:  
 Thay th ế toàn c ục (Global Replacement)  
 Thay th ế cục bộ (Local Replacement)  
a) Thay th ế toàn c ục  
Chọn trang “n ạn nhân” t ừ tập tất cả các khung trang trong h ệ thống, khung trang 
đó có th ể đang đƣ ợc cấp phát cho m ột tiến trình khác.  
Ví dụ: có th ể chọn trang c ủa tiến trình có đ ộ ƣu tiên th ấp hơn làm trang n ạn nhân.  
Thuật toán thay th ế toàn c ục cho phép h ệ thống có nhi ều khả năng l ựa chọn hơn, 
số khung trang c ấp cho m ột tiến trình có th ể thay đ ổi, nhƣng các ti ến trình khôn g thể 
kiểm soát đƣ ợc tỷ lệ phát sinh l ỗi trang c ủa mình.  
b) Thay th ế cục bộ  
Chỉ chọn trang thay th ế trong t ập các khung trang đƣ ợc cấp cho ti ến trình phát 
sinh l ỗi trang, khi đó s ố khung trang c ấp cho m ột tiến trình s ẽ không thay đ ổi.  
 Trì tr ệ hệ thống (Th rashing)
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  79  Khi ti ến trình không có đ ủ các khung trang đ ể chứa những trang c ần thi ết cho 
việc xử lý, nó s ẽ thƣờng xuyên phát sinh các l ỗi trang. Vì th ế phải dùng đ ến rất nhiều 
thời gian s ử dụng CPU đ ể thực hiện thay th ế trang. H ệ điều hành th ấy hiệu quả sử 
dụng CPU th ấp sẽ tăng m ức độ đa chƣơng d ẫn đến trì tr ệ toàn b ộ hệ thống.  
Để ngăn c ản tình tr ạng trì tr ệ này x ảy ra, c ần phải cấp cho ti ến trình đ ủ các khung 
trang c ần thiết để hoạt động. V ấn đề là làm sao bi ết đƣợc mỗi tiến trình c ần bao nhiêu 
trang?  
a) Mô hình t ập làm vi ệc (Working -Set Model)  
Tập làm vi ệc của tiến trình t ại thời điểm t là t ập các trang đƣ ợc tiến trình truy xu ất 
đến trong Δ l ần truy c ập cuối cùng tính t ại thời điểm t  
 
 
 
 
 
 
Hình 5.2 3. Mô hình t ập làm vi ệc 
Gọi:  
WSSi(Δ, t) là s ố phần tử của tập working -set của tiến trình Pi t ại thời điểm t 
m là s ố khung trang tr ống  
ΣWSSi  là t ổng số khung trang yêu c ầu cho toàn h ệ thống  
Hệ điều hành giám sát working -set của mỗi tiến trình Pi và t ại thời điểm t s ẽ cấp 
phát cho ti ến trình Pi s ố khung trang  bằng với số phần tử trong t ập làm vi ệc   
(WSS i)(Δ, t - 1)  
Nếu tổng số khung trang yêu c ầu của các ti ến trình trong h ệ thống vƣ ợt quá các  
khung trang có th ể sử dụng (D>m), thì s ẽ xảy ra tình tr ạng hệ thống trì tr ệ. Khi đó h ệ 
điều hành ch ọn một tiến trình  để tạm dừng, gi ải phóng các khung trang c ủa tiến trình 
đã ch ọn để các ti ến trình khác có đ ủ khung trang hoàn t ất công vi ệc.  
b) Cấu trúc chương trình  
Số lỗi trang có khi ph ụ thuộc vào ngôn ng ữ lập trình, nên khi l ập trình ta c ần chú 
ý để chƣơng trình có thể thực hiện nhanh hơn.  
Ví dụ: xét chƣơng trình sau    int 
a[128][128];    for (i=0; i<128; 
i++)      for (j=0; j<128; 
j++) a[i][j]=0;
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  80  Giả sử trang có kích thƣ ớc 128 byte và ti ến trình đƣ ợc cấp 2 khung trang: khung 
trang th ứ nhất chứa mã ti ến trình, khu ng trang còn l ại đƣợc khởi động ở trạng thái 
trống. trong Pascal, C thì m ảng lƣu theo hàng, m ỗi hàng chi ếm 1 trang b ộ nhớ nên 
tổng số lỗi trang phát sinh là 128. Nhƣng trong Fortran thì m ảng lƣu theo c ột, do đó s ố 
lỗi trang s ẽ là 128 x 128 = 16384 .  
TÓM T ẮT CHƢƠNG  
 Tiến trình là m ột chƣơng trình đang ho ạt động.  
 Để sử dụng hi ệu quả CPU, s ự đa chƣơng c ần đƣợc đƣa vào h ệ thống.  
Sự đa chƣơng đƣ ợc tổ chức bằng cách lƣu tr ữ nhiều tiến trình trong b ộ nhớ tại 
một thời điểm và đi ều phối CPU qua l ại giữa các ti ến trình trong h ệ thống. 
 Trong su ốt chu trình s ống, ti ến trình chuy ển đổi qua l ại giữa các tr ạng thái 
ready, running và blocked.  
 Mô hình đa thread cho phép m ỗi tiến trình có th ể tiến hành nhi ều dòng x ử 
lý đồng th ời trong cùng m ột không gian đ ịa chỉ nhằm thực hiện tác v ụ hiệu 
quả hơn trong m ột số trƣờng hợp.  
 Bộ điều phối (scheduler) c ủa hệ điều hành ch ịu trách nhi ệm áp d ụng m ột 
giải thu ật điều phối thích h ợp để chọn tiến trình thích h ợp đƣ ợc sử dụng 
CPU, và b ộ phân ph ối (dispatcher) s ẽ chuy ển giao CPU cho ti ến trình này.   
 Các gi ải thuật điều phối thông d ụng: FIFO, Round Robin, đ ộ ƣu tiên, SJF, 
đa cấp độ.  
 Các gi ải pháp đ ồng b ộ hóa do l ập trình viên xây d ựng không đƣ ợc ƣa 
chuộng vì ph ải tiêu th ụ CPU trong th ời gian ch ờ vào mi ền tranh ch ấp 
(“busy waiting”) và kh ó mở rộng. Thay vào đó, l ập trình viên có th ể sử 
dụng các cơ ch ế đồng bộ do hệ điều hành hay trình biên d ịch trợ giúp nhƣ 
semaphore, monitor, trao đ ổi thông đi ệp.  
 Tắc ngh ẽn là tình tr ạng xảy ra trong m ột tập các ti ến trình n ếu có hai hay 
nhiều hơn các ti ến trình ch ờ đợi vô h ạn một sự kiện chỉ có th ể đƣợc phát 
sinh b ởi một tiến trình cũng đang ch ờ khác trong t ập các ti ến trình này.  
 Có 3 hƣ ớng tiếp cận chính trong x ử lý tắc ngh ẽn: o Phòng tránh t ắc ngh ẽn: 
tuân th ủ một vài nghi th ức bảo đảm hệ thống không ba o giờ lâm vào tr ạng 
thái t ắc ngh ẽn. o Phát hi ện tắc ngh ẽn: khi có t ắc ngh ẽn xảy ra, phát hi ện 
các ti ến trình liên quan và tìm cách ph ục hồi. o Bỏ qua t ắc ngh ẽn: xem nhƣ 
hệ thống không bao gi ờ lâm vào tr ạng thái t ắc ngh ẽn.
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  81  BÀI T ẬP  
1) Nhiều hệ điều hành không  cho phép x ử lý đồng hành. Th ảo luận về các ph ức 
tạp phát sinh khi h ệ điều hành cho phép đa chƣơng?  
2) Xét t ập các ti ến trình sau (v ới thời gian yêu c ầu CPU và đ ộ ƣu tiên kèm theo):  
  
Tiến trình  Thời đi ểm vào 
RL  Thời gian 
CPU  Độ ƣu tiên  
P1  0  10  3  
P2  1  1  1  
P3  2  2  3  
P4  3  1  4  
P5  4  5  2  
a. Cho bi ết kết quả điều phối hoạt động của các ti ến trình trên theo thu ật 
toán FIFO; SJF; đi ều phối theo đ ộ ƣu tiên (1 > 2 > 3 >…) preemptive 
và non -preemptive; Round Robin v ới Quantum=2.  
b. Cho bi ết thời gian lƣu l ại trong h ệ thống (Turn arround time) c ủa từng 
tiến trình trong t ừng thu ật toán đi ều phối ở câu a.  
c. Cho bi ết thời gian ch ờ trong h ệ thống (waiting time) c ủa từng tiến trình 
trong t ừng thu ật toán đi ều phối ở câu a.  
d. Thuật toán đi ều phối nào trong  các thu ật toán ở câu a cho th ời gian ch ờ 
là cực tiểu?  
3) Phân bi ệt sự khác nhau trong cách ti ếp cận để ƣu tiên cho ti ến trình ng ắn trong 
các thu ật toán đi ều phối sau:  
a. FIFO  
b. Round Robin  
c. Điều phối với độ ƣu tiên đa c ấp.  
4) Cho bi ết hai ƣu đi ểm chính c ủa mô hì nh đa ti ểu trình so v ới đa ti ến trình. Mô 
tả một ứng dụng thích h ợp với mô hình đa ti ểu trình và m ột ứng dụng khác 
không thích h ợp.  
5) Mô t ả các x ử lý hệ điều hành ph ải thực hiện khi chuy ển đổi ngữ cảnh gi ữa: a. 
Các ti ến trình  
b. Các ti ểu trình  
6) Xác đ ịnh th ời lƣợng quantum q là m ột nhi ệm vụ khó khăn. Gi ả sử chi phí 
trung bình cho m ột lần chuy ển đổi ngữ cảnh là s, và th ời gian trung bình m ột
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  82  tiến trình hƣ ớng nh ập xuất sử dụng CPU trƣ ớc khi phát sinh m ột yêu c ầu nhập 
xuất là t  (t >> s). Th ảo luận các tác đ ộng đến sự thực hiện của hệ thống khi 
chọn lựa q theo các quy t ắc sau:  
a. q bất định  
b. q lớn hơn 0 m ột ít.  
c. q = s  
d. s < q < t  
e. q = t  
f. q > t  
7) Giả sử một hệ điều hành áp d ụng gi ải thuật điều phối multilevel feedback v ới 
5 mức ƣu tiên (gi ảm dần). Th ời lƣợng quantum dành cho hàng đ ợi cấp 1 là 
0.5s. M ỗi hàng đ ợi cấp thấp hơn s ẽ có th ời lƣợng quantum dài g ấp đôi hàng 
đợi với mức ƣu tiên cao hơn nó. M ột tiến trình khi vào h ệ thống sẽ đƣợc đƣa 
vào hàng đ ợi mức cao nh ất, và chuy ển dần xuống các hàng đ ợi bên dƣ ới sau 
mỗi lƣợt sử dụng CPU. M ột tiến trình ch ỉ có th ể bị thu h ồi CPU khi đã s ử 
dụng hết thời lƣợng quantum dành cho nó. H ệ thống có th ể thực hiện các tác 
vụ xử lý theo lô ho ặc tƣơng tác và m ỗi tác v ụ lại có th ể hƣớng x ử lý ho ặc 
hƣớng nh ập xuất.  
a. Giải thích t ại sao h ệ thống này ho ạt động không hi ệu quả?  
b. Cần phải thay đ ổi (tối thiểu) nhƣ th ế nào đ ể hệ thống đi ều phối 
các tác v ụ với những bản chất khác bi ệt nhƣ th ế tốt hơn?  
8) Xét hai ti ến trình x ử lý đo ạn chƣơng trình sau:  
process P1 {A1 ; A2} 
process P2 {B1 ; B2}  
Đồng bộ hóa ho ạt động của hai ti ến trình này sao cho c ả A1 và B1 đ ều hoàn 
tất trƣớc khi A2 hay B2 b ắt đầu.  
9) Cho các ti ến trình x ử lý đo ạn chƣơng trình sau:  
process P1 {for (i=1; i<=100; i++) Ai;} 
process P2 {for (j=1; j<=100; j++) Bj;}  
Đồng b ộ hóa ho ạt động c ủa hai ti ến trình này sao cho c ả với k b ất kỳ 
(2<=k<=100), Ak ch ỉ có th ể bắt đầu khi B(k -1) đã k ết thúc, và Bk ch ỉ có th ể 
bắt đầu khi A(k -1) đã k ết thúc.  
10) Xét tr ạng thái h ệ thống:  
   Max    Allocation     Available    
R1  R2  R3  R1  R2  R3  R1  R2  R3
HỆ ĐIỀU HÀNH  
 
 
TRƢ ỜNG Đ ẠI HỌC NAM C ẦN THƠ – KHOA KTCN  Trang  83  P1  3  2  2  1  1  0  
4  1  2  P2  7  1  3  2  1  1  
P3  4  1  4  2  1  1  
P4  5  2  2  0  0  2  
Nếu tiến trình P2 yêu c ầu 4 cho R1, 1 cho R3. Hãy cho bi ết yêu c ầu này có th ể 
đáp ứng mà b ảo đảm không x ảy ra tình tr ạng deadlock hay không?